<!DOCTYPE html>
<html style="display: none;" lang="zh">
    <head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.5.2 -->
    <script>
        window.materialVersion = "1.5.2"
        // Delete localstorage with these tags
        window.oldVersion = [
            'codestartv1',
            '1.3.4',
            '1.4.0',
            '1.4.0b1',
            '1.5.0'
        ]
    </script>

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">














    <!-- Meta & Info -->
    <meta http-equiv="X-UA-Compatible" content="IE=Edge,chrome=1">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

    <!-- Title -->
    
    <title>
        
            IOI2021集训队作业 | 
        
        Mrsrz&#39;s blog
    </title>

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/head.png">
    <link rel="icon" href="/img/head.png">

    <meta name="format-detection" content="telephone=no">
    <meta name="description" itemprop="description" content>
    <meta name="keywords" content=",作业">
    <meta name="theme-color" content="#0097A7">

    <!-- Disable Fucking Bloody Baidu Tranformation -->
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import lsloader -->
    <script>(function(){window.lsloader={jsRunSequence:[],jsnamemap:{},cssnamemap:{}};lsloader.removeLS=function(a){try{localStorage.removeItem(a)}catch(b){}};lsloader.setLS=function(a,c){try{localStorage.setItem(a,c)}catch(b){}};lsloader.getLS=function(a){var c="";try{c=localStorage.getItem(a)}catch(b){c=""}return c};versionString="/*"+(window.materialVersion||"unknownVersion")+"*/";lsloader.clean=function(){try{var b=[];for(var a=0;a<localStorage.length;a++){b.push(localStorage.key(a))}b.forEach(function(e){var f=lsloader.getLS(e);if(window.oldVersion){var d=window.oldVersion.reduce(function(g,h){return g||f.indexOf("/*"+h+"*/")!==-1},false);if(d){lsloader.removeLS(e)}}})}catch(c){}};lsloader.clean();lsloader.load=function(f,a,b,d){if(typeof b==="boolean"){d=b;b=undefined}d=d||false;b=b||function(){};var e;e=this.getLS(f);if(e&&e.indexOf(versionString)===-1){this.removeLS(f);this.requestResource(f,a,b,d);return}if(e){var c=e.split(versionString)[0];if(c!=a){console.log("reload:"+a);this.removeLS(f);this.requestResource(f,a,b,d);return}e=e.split(versionString)[1];if(d){this.jsRunSequence.push({name:f,code:e});this.runjs(a,f,e)}else{document.getElementById(f).appendChild(document.createTextNode(e));b()}}else{this.requestResource(f,a,b,d)}};lsloader.requestResource=function(b,e,a,c){var d=this;if(c){this.iojs(e,b,function(h,f,g){d.setLS(f,h+versionString+g);d.runjs(h,f,g)})}else{this.iocss(e,b,function(f){document.getElementById(b).appendChild(document.createTextNode(f));d.setLS(b,e+versionString+f)},a)}};lsloader.iojs=function(d,b,g){var a=this;a.jsRunSequence.push({name:b,code:""});try{var f=new XMLHttpRequest();f.open("get",d,true);f.onreadystatechange=function(){if(f.readyState==4){if((f.status>=200&&f.status<300)||f.status==304){if(f.response!=""){g(d,b,f.response);return}}a.jsfallback(d,b)}};f.send(null)}catch(c){a.jsfallback(d,b)}};lsloader.iocss=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.iofonts=function(f,c,h,a){var b=this;try{var g=new XMLHttpRequest();g.open("get",f,true);g.onreadystatechange=function(){if(g.readyState==4){if((g.status>=200&&g.status<300)||g.status==304){if(g.response!=""){h(g.response);a();return}}b.cssfallback(f,c,a)}};g.send(null)}catch(d){b.cssfallback(f,c,a)}};lsloader.runjs=function(f,c,e){if(!!c&&!!e){for(var b in this.jsRunSequence){if(this.jsRunSequence[b].name==c){this.jsRunSequence[b].code=e}}}if(!!this.jsRunSequence[0]&&!!this.jsRunSequence[0].code&&this.jsRunSequence[0].status!="failed"){var a=document.createElement("script");a.appendChild(document.createTextNode(this.jsRunSequence[0].code));a.type="text/javascript";document.getElementsByTagName("head")[0].appendChild(a);this.jsRunSequence.shift();if(this.jsRunSequence.length>0){this.runjs()}}else{if(!!this.jsRunSequence[0]&&this.jsRunSequence[0].status=="failed"){var d=this;var a=document.createElement("script");a.src=this.jsRunSequence[0].path;a.type="text/javascript";this.jsRunSequence[0].status="loading";a.onload=function(){d.jsRunSequence.shift();if(d.jsRunSequence.length>0){d.runjs()}};document.body.appendChild(a)}}};lsloader.tagLoad=function(b,a){this.jsRunSequence.push({name:a,code:"",path:b,status:"failed"});this.runjs()};lsloader.jsfallback=function(c,b){if(!!this.jsnamemap[b]){return}else{this.jsnamemap[b]=b}for(var a in this.jsRunSequence){if(this.jsRunSequence[a].name==b){this.jsRunSequence[a].code="";this.jsRunSequence[a].status="failed";this.jsRunSequence[a].path=c}}this.runjs()};lsloader.cssfallback=function(e,c,b){if(!!this.cssnamemap[c]){return}else{this.cssnamemap[c]=1}var d=document.createElement("link");d.type="text/css";d.href=e;d.rel="stylesheet";d.onload=d.onerror=b;var a=document.getElementsByTagName("script")[0];a.parentNode.insertBefore(d,a)};lsloader.runInlineScript=function(c,b){var a=document.getElementById(b).innerText;this.jsRunSequence.push({name:c,code:a});this.runjs()}})();</script>

    <!-- Import queue -->
    <script>function Queue(){this.dataStore=[];this.offer=b;this.poll=d;this.execNext=a;this.debug=false;this.startDebug=c;function b(e){if(this.debug){console.log("Offered a Queued Function.")}if(typeof e==="function"){this.dataStore.push(e)}else{console.log("You must offer a function.")}}function d(){if(this.debug){console.log("Polled a Queued Function.")}return this.dataStore.shift()}function a(){var e=this.poll();if(e!==undefined){if(this.debug){console.log("Run a Queued Function.")}e()}}function c(){this.debug=true}}var queue=new Queue();</script>

    <!-- Import CSS -->
    
        <style id="material_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_css","/css/material.min.css?Z7a72R1E4SxzBKR/WGctOA==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
        <style id="style_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("style_css","/css/style.min.css?MKetZV3cUTfDxvMffaOezg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>

        
            
                <style id="prettify_css"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_css","/css/prettify.min.css?zp8STOU9v89XWFEnN+6YmQ==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
                <style id="prettify_theme"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("prettify_theme","/css/prettify/github-v2.min.css?AfzKxt++K+/lhZBlSjnxwg==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>
            
        

    

    

    <!-- Config CSS -->

<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
    overflow-x: hidden !important;
  }
  
  code {
    font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-image: url(/img/Chtholly.jpg);
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


<!-- Import Font -->
<!-- Import Roboto -->

    <link href="https://fonts.googleapis.com/css?family=Roboto:300,400,500" rel="stylesheet">


<!-- Import Material Icons -->


    <style id="material_icons"></style><script>if(typeof window.lsLoadCSSMaxNums === "undefined")window.lsLoadCSSMaxNums = 0;window.lsLoadCSSMaxNums++;lsloader.load("material_icons","/css/material-icons.css?pqhB/Rd/ab0H2+kZp0RDmw==",function(){if(typeof window.lsLoadCSSNums === "undefined")window.lsLoadCSSNums = 0;window.lsLoadCSSNums++;if(window.lsLoadCSSNums == window.lsLoadCSSMaxNums)document.documentElement.style.display="";}, false)</script>




    <!-- Import jQuery -->
    
        <script>lsloader.load("jq_js","/js/jquery.min.js?qcusAULNeBksqffqUM2+Ig==", true)</script>
    

    <!-- WebAPP Icons -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="application-name" content="Mrsrz&#39;s blog">
    <meta name="msapplication-starturl" content="http://yoursite.com/IOI2021hw/">
    <meta name="msapplication-navbutton-color" content="#0097A7">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-title" content="Mrsrz&#39;s blog">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon" href="/img/head.png">

    <!-- Site Verification -->
    
    

    <!-- RSS -->
    

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://yoursite.com/IOI2021hw/">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="IOI2021集训队作业 | Mrsrz&#39;s blog">
    <meta property="og:image" content="/img/head.png">
    <meta property="og:description" content>
    <meta property="og:article:tag" content="作业"> 

    
        <meta property="article:published_time" content="Mon Oct 12 2020 18:35:14 GMT+0800">
        <meta property="article:modified_time" content="Tue Dec 08 2020 12:01:02 GMT+0800">
    

    <!-- The Twitter Card protocol -->
    <meta name="twitter:card" content="summary_large_image">

    <!-- Add canonical link for SEO -->
    
        <link rel="canonical" href="http://yoursite.com/IOI2021hw/index.html">
    

    <!-- Structured-data for SEO -->
    
        


<script type="application/ld+json">
{
    "@context": "https://schema.org",
    "@type": "BlogPosting",
    "mainEntityOfPage": "http://yoursite.com/IOI2021hw/index.html",
    "headline": "IOI2021集训队作业",
    "datePublished": "Mon Oct 12 2020 18:35:14 GMT+0800",
    "dateModified": "Tue Dec 08 2020 12:01:02 GMT+0800",
    "author": {
        "@type": "Person",
        "name": "mrsrz",
        "image": {
            "@type": "ImageObject",
            "url": "/img/head.png"
        },
        "description": "珂愛"
    },
    "publisher": {
        "@type": "Organization",
        "name": "Mrsrz&#39;s blog",
        "logo": {
            "@type":"ImageObject",
            "url": "/img/head.png"
        }
    },
    "keywords": ",作业",
    "description": "",
}
</script>


    

    <!-- Analytics -->
    
    
    

    <!-- Custom Head -->
    

</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->


    <!-- Left aligned menu below button -->
    
    
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#AK"><span class="post-toc-number">1.</span> <span class="post-toc-text">AK</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意："><span class="post-toc-number">1.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解："><span class="post-toc-number">1.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code："><span class="post-toc-number">1.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#RE"><span class="post-toc-number">2.</span> <span class="post-toc-text">RE</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-1"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-1"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-1"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#OJ"><span class="post-toc-number">3.</span> <span class="post-toc-text">OJ</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-2"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-2"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-2"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#LI"><span class="post-toc-number">4.</span> <span class="post-toc-text">LI</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-3"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-3"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-3"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#FB"><span class="post-toc-number">5.</span> <span class="post-toc-text">FB</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-4"><span class="post-toc-number">5.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-4"><span class="post-toc-number">5.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-4"><span class="post-toc-number">5.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#FG"><span class="post-toc-number">6.</span> <span class="post-toc-text">FG</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-5"><span class="post-toc-number">6.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-5"><span class="post-toc-number">6.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-5"><span class="post-toc-number">6.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#LL"><span class="post-toc-number">7.</span> <span class="post-toc-text">LL</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-6"><span class="post-toc-number">7.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-6"><span class="post-toc-number">7.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-6"><span class="post-toc-number">7.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#QE"><span class="post-toc-number">8.</span> <span class="post-toc-text">QE</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-7"><span class="post-toc-number">8.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-7"><span class="post-toc-number">8.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-7"><span class="post-toc-number">8.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#RJ"><span class="post-toc-number">9.</span> <span class="post-toc-text">RJ</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-8"><span class="post-toc-number">9.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-8"><span class="post-toc-number">9.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-8"><span class="post-toc-number">9.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#RG"><span class="post-toc-number">10.</span> <span class="post-toc-text">RG</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-9"><span class="post-toc-number">10.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-9"><span class="post-toc-number">10.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-9"><span class="post-toc-number">10.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#CK"><span class="post-toc-number">11.</span> <span class="post-toc-text">CK</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-10"><span class="post-toc-number">11.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-10"><span class="post-toc-number">11.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-10"><span class="post-toc-number">11.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#KH"><span class="post-toc-number">12.</span> <span class="post-toc-text">KH</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-11"><span class="post-toc-number">12.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-11"><span class="post-toc-number">12.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-11"><span class="post-toc-number">12.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#IK"><span class="post-toc-number">13.</span> <span class="post-toc-text">IK</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-12"><span class="post-toc-number">13.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-12"><span class="post-toc-number">13.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-12"><span class="post-toc-number">13.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#RI"><span class="post-toc-number">14.</span> <span class="post-toc-text">RI</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-13"><span class="post-toc-number">14.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-13"><span class="post-toc-number">14.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-13"><span class="post-toc-number">14.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#GJ"><span class="post-toc-number">15.</span> <span class="post-toc-text">GJ</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-14"><span class="post-toc-number">15.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-14"><span class="post-toc-number">15.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-14"><span class="post-toc-number">15.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#TF"><span class="post-toc-number">16.</span> <span class="post-toc-text">TF</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-15"><span class="post-toc-number">16.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-15"><span class="post-toc-number">16.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-15"><span class="post-toc-number">16.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#BL"><span class="post-toc-number">17.</span> <span class="post-toc-text">BL</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-16"><span class="post-toc-number">17.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-16"><span class="post-toc-number">17.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-16"><span class="post-toc-number">17.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#QF"><span class="post-toc-number">18.</span> <span class="post-toc-text">QF</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-17"><span class="post-toc-number">18.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-17"><span class="post-toc-number">18.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-17"><span class="post-toc-number">18.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#UJ"><span class="post-toc-number">19.</span> <span class="post-toc-text">UJ</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-18"><span class="post-toc-number">19.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-18"><span class="post-toc-number">19.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-18"><span class="post-toc-number">19.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#NF"><span class="post-toc-number">20.</span> <span class="post-toc-text">NF</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-19"><span class="post-toc-number">20.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-19"><span class="post-toc-number">20.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-19"><span class="post-toc-number">20.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#GK"><span class="post-toc-number">21.</span> <span class="post-toc-text">GK</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-20"><span class="post-toc-number">21.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-20"><span class="post-toc-number">21.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-20"><span class="post-toc-number">21.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#LK"><span class="post-toc-number">22.</span> <span class="post-toc-text">LK</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-21"><span class="post-toc-number">22.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-21"><span class="post-toc-number">22.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-21"><span class="post-toc-number">22.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#IJ"><span class="post-toc-number">23.</span> <span class="post-toc-text">IJ</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-22"><span class="post-toc-number">23.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-22"><span class="post-toc-number">23.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-22"><span class="post-toc-number">23.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#IB"><span class="post-toc-number">24.</span> <span class="post-toc-text">IB</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-23"><span class="post-toc-number">24.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-23"><span class="post-toc-number">24.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-23"><span class="post-toc-number">24.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#TK"><span class="post-toc-number">25.</span> <span class="post-toc-text">TK</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-24"><span class="post-toc-number">25.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-24"><span class="post-toc-number">25.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-24"><span class="post-toc-number">25.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#PD"><span class="post-toc-number">26.</span> <span class="post-toc-text">PD</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-25"><span class="post-toc-number">26.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-25"><span class="post-toc-number">26.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-25"><span class="post-toc-number">26.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li><li class="post-toc-item post-toc-level-1"><a class="post-toc-link" href="#QG"><span class="post-toc-number">27.</span> <span class="post-toc-text">QG</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题目大意：-26"><span class="post-toc-number">27.1.</span> <span class="post-toc-text">题目大意：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#题解：-26"><span class="post-toc-number">27.2.</span> <span class="post-toc-text">题解：</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#Code：-26"><span class="post-toc-number">27.3.</span> <span class="post-toc-text">Code：</span></a></li></ol></li></ol>
    </ul>
    




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script type="text/ls-javascript" id="post-thumbnail-script">
    var randomNum = Math.floor(Math.random() * 5 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/qaq-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                IOI2021集训队作业
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/head.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>mrsrz</strong>
        <span>10月 12, 2020</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        <a class="post_tag-link" href="/tags/作业/">作业</a>
    </ul>
    

    <!-- Share -->
    
        <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=IOI2021集训队作业&url=http://yoursite.com/IOI2021hw/index.html&pic=http://yoursite.com/img/head.png&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=IOI2021集训队作业&url=http://yoursite.com/IOI2021hw/index.html&via=mrsrz" target="_blank">
            <li class="mdl-menu__item">
                分享到 Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://yoursite.com/IOI2021hw/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://yoursite.com/IOI2021hw/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    

    <!-- Share Telegram -->
    
</ul>

    
</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <p>IOI2021 集训队作业，持续更新。表格内打 <code>*</code> 的表示还未写题解。</p>
<hr>
<div class="table-container">
<table>
<thead>
<tr>
<th>试题一</th>
<th>完成情况</th>
<th>试题二</th>
<th>完成情况</th>
<th>试题三</th>
<th>完成情况</th>
</tr>
</thead>
<tbody>
<tr>
<td><a href="https://codeforces.com/gym/100269/problem/C" target="_blank" rel="noopener">UC</a></td>
<td><a href="#UC">✔</a>(2020.11.12)(*)</td>
<td><a href="https://codeforces.com/gym/101471/problem/G" target="_blank" rel="noopener">DG</a></td>
<td><a href="#DG">✔</a>(2020.10.29)(*)</td>
<td><a href="https://codeforces.com/gym/101142/problem/B" target="_blank" rel="noopener">RB</a></td>
<td><a href="#RB">✔</a>(2020.12.1)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101190/problem/C" target="_blank" rel="noopener">HC</a></td>
<td><a href="#HC">✔</a>(2020.11.26)(*)</td>
<td><a href="https://codeforces.com/gym/100851/problem/B" target="_blank" rel="noopener">IB</a></td>
<td><a href="#IB">✔</a>(2020.11.9)</td>
<td><a href="https://codeforces.com/gym/102511/problem/J" target="_blank" rel="noopener">FJ</a></td>
<td><a href="#FJ">✔</a>(2020.11.20)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101630/problem/K" target="_blank" rel="noopener">GK</a></td>
<td><a href="#GK">✔</a>(2020.11.4)</td>
<td><a href="https://codeforces.com/gym/100269/problem/H" target="_blank" rel="noopener">UH</a></td>
<td><a href="#UH">✔</a>(2020.11.11)(*)</td>
<td><a href="https://codeforces.com/gym/101612/problem/H" target="_blank" rel="noopener">QH</a></td>
<td><a href="#QH">✔</a>(2020.11.13)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/102482/problem/E" target="_blank" rel="noopener">EE</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101471/problem/J" target="_blank" rel="noopener">DJ</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/100851/problem/H" target="_blank" rel="noopener">IH</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101190/problem/L" target="_blank" rel="noopener">HL</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101173/problem/I" target="_blank" rel="noopener">MI</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/102482/problem/J" target="_blank" rel="noopener">EJ</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101173/problem/B" target="_blank" rel="noopener">MB</a></td>
<td><a href="#MB">✔</a>(2020.11.6)(*)</td>
<td><a href="https://codeforces.com/gym/100269/problem/I" target="_blank" rel="noopener">UI</a></td>
<td><a href="#UI">✔</a>(2020.11.24)(*)</td>
<td><a href="https://codeforces.com/gym/102482/problem/D" target="_blank" rel="noopener">ED</a></td>
<td><a href="#ED">✔</a>(2020.10.30)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101221/problem/A" target="_blank" rel="noopener">AA</a></td>
<td><a href="#AA">✔</a>(2020.11.5)(*)</td>
<td><a href="https://codeforces.com/gym/101239/problem/G" target="_blank" rel="noopener">BG</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101173/problem/L" target="_blank" rel="noopener">ML</a></td>
<td><a href="#ML">✔</a>(2020.11.15)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101242/problem/F" target="_blank" rel="noopener">CF</a></td>
<td><a href="#CF">✔</a>(2020.12.7)(*)</td>
<td><a href="https://codeforces.com/gym/100531/problem/E" target="_blank" rel="noopener">TE</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101612/problem/G" target="_blank" rel="noopener">QG</a></td>
<td><a href="#QG">✔</a>(2020.11.21)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100299/problem/H" target="_blank" rel="noopener">PH</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/100269/problem/J" target="_blank" rel="noopener">UJ</a></td>
<td><a href="#UJ">✔</a>(2020.10.24)</td>
<td><a href="https://codeforces.com/gym/101239/problem/B" target="_blank" rel="noopener">BB</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101242/problem/I" target="_blank" rel="noopener">CI</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/100801/problem/D" target="_blank" rel="noopener">SD</a></td>
<td><a href="#SD">✔</a>(2020.11.3)(*)</td>
<td><a href="https://codeforces.com/gym/101480/problem/G" target="_blank" rel="noopener">NG</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101471/problem/K" target="_blank" rel="noopener">DK</a></td>
<td><a href="#DK">✔</a>(2020.12.2)(*)</td>
<td><a href="https://codeforces.com/gym/101620/problem/D" target="_blank" rel="noopener">LD</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/100851/problem/J" target="_blank" rel="noopener">IJ</a></td>
<td><a href="#IJ">✔</a>(2020.11.8)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101480/problem/C" target="_blank" rel="noopener">NC</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101239/problem/J" target="_blank" rel="noopener">BJ</a></td>
<td><a href="#BJ">✔</a>(2020.11.6)(*)</td>
<td><a href="https://codeforces.com/gym/102511/problem/K" target="_blank" rel="noopener">FK</a></td>
<td><a href="#FK">✔</a>(2020.11.24)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101242/problem/H" target="_blank" rel="noopener">CH</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101480/problem/J" target="_blank" rel="noopener">NJ</a></td>
<td><a href="#NJ">✔</a>(2020.11.22)(*)</td>
<td><a href="https://codeforces.com/gym/101142/problem/H" target="_blank" rel="noopener">RH</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101612/problem/F" target="_blank" rel="noopener">QF</a></td>
<td><a href="#QF">✔</a>(2020.10.24)</td>
<td><a href="https://codeforces.com/gym/101239/problem/E" target="_blank" rel="noopener">BE</a></td>
<td><a href="#BE">✔</a>(2020.11.20)(*)</td>
<td><a href="https://codeforces.com/gym/100307/problem/I" target="_blank" rel="noopener">KI</a></td>
<td><a href="#KI">✔</a>(2020.11.25)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101221/problem/C" target="_blank" rel="noopener">AC</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/100299/problem/G" target="_blank" rel="noopener">PG</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101190/problem/M" target="_blank" rel="noopener">HM</a></td>
<td><a href="#HM">✔</a>(2020.11.22)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100299/problem/J" target="_blank" rel="noopener">PJ</a></td>
<td><a href="#PJ">✔</a>(2020.11.18)(*)</td>
<td><a href="https://codeforces.com/gym/100851/problem/D" target="_blank" rel="noopener">ID</a></td>
<td><a href="#ID">✔</a>(2020.12.7)(*)</td>
<td><a href="https://codeforces.com/gym/102482/problem/G" target="_blank" rel="noopener">EG</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100801/problem/I" target="_blank" rel="noopener">SI</a></td>
<td><a href="#SI">✔</a>(2020.11.13)(*)</td>
<td><a href="https://codeforces.com/gym/100307/problem/C" target="_blank" rel="noopener">KC</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101630/problem/I" target="_blank" rel="noopener">GI</a></td>
<td><a href="#GI">✔</a>(2020.11.11)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100543/problem/G" target="_blank" rel="noopener">OG</a></td>
<td><a href="#OG">✔</a>(2020.10.28)(*)</td>
<td><a href="https://codeforces.com/gym/101242/problem/K" target="_blank" rel="noopener">CK</a></td>
<td><a href="#CK">✔</a>(2020.10.14)</td>
<td><a href="https://codeforces.com/gym/101471/problem/B" target="_blank" rel="noopener">DB</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101612/problem/E" target="_blank" rel="noopener">QE</a></td>
<td><a href="#QE">✔</a>(2020.10.14)</td>
<td><a href="https://codeforces.com/gym/101630/problem/H" target="_blank" rel="noopener">GH</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101480/problem/I" target="_blank" rel="noopener">NI</a></td>
<td><a href="#NI">✔</a>(2020.11.10)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100543/problem/L" target="_blank" rel="noopener">OL</a></td>
<td><a href="#OL">✔</a>(2020.10.26)(*)</td>
<td><a href="https://codeforces.com/gym/100307/problem/A" target="_blank" rel="noopener">KA</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101173/problem/G" target="_blank" rel="noopener">MG</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100801/problem/G" target="_blank" rel="noopener">SG</a></td>
<td><a href="#SG">✔</a>(2020.11.10)(*)</td>
<td><a href="https://codeforces.com/gym/101480/problem/L" target="_blank" rel="noopener">NL</a></td>
<td><a href="#NL">✔</a>(2020.12.7)(*)</td>
<td><a href="https://codeforces.com/gym/100307/problem/H" target="_blank" rel="noopener">KH</a></td>
<td><a href="#KH">✔</a>(2020.10.22)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101612/problem/J" target="_blank" rel="noopener">QJ</a></td>
<td><a href="#QJ">✔</a>(2020.12.6)(*)</td>
<td><a href="https://codeforces.com/gym/100307/problem/G" target="_blank" rel="noopener">KG</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101221/problem/B" target="_blank" rel="noopener">AB</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100307/problem/D" target="_blank" rel="noopener">KD</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/100851/problem/L" target="_blank" rel="noopener">IL</a></td>
<td><a href="#IL">✔</a>(2020.11.9)(*)</td>
<td><a href="https://codeforces.com/gym/101480/problem/F" target="_blank" rel="noopener">NF</a></td>
<td><a href="#NF">✔</a>(2020.10.31)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101242/problem/M" target="_blank" rel="noopener">CM</a></td>
<td><a href="#CM">✔</a>(2020.11.27)(*)</td>
<td><a href="https://codeforces.com/gym/101480/problem/E" target="_blank" rel="noopener">NE</a></td>
<td><a href="#NE">✔</a>(2020.11.15)(*)</td>
<td><a href="https://codeforces.com/gym/101190/problem/D" target="_blank" rel="noopener">HD</a></td>
<td><a href="#HD">✔</a>(2020.11.18)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101471/problem/H" target="_blank" rel="noopener">DH</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/102482/problem/C" target="_blank" rel="noopener">EC</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101239/problem/M" target="_blank" rel="noopener">BM</a></td>
<td><a href="#BM">✔</a>(2020.11.19)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101620/problem/C" target="_blank" rel="noopener">LC</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101242/problem/D" target="_blank" rel="noopener">CD</a></td>
<td><a href="#CD">✔</a>(2020.11.11)(*)</td>
<td><a href="https://codeforces.com/gym/100553/problem/I" target="_blank" rel="noopener">JI</a></td>
<td><a href="#JI">✔</a>(2020.11.12)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101471/problem/L" target="_blank" rel="noopener">DL</a></td>
<td><a href="#DL">✔</a>(2020.11.25)(*)</td>
<td><a href="https://codeforces.com/gym/101173/problem/E" target="_blank" rel="noopener">ME</a></td>
<td><a href="#ME">✔</a>(2020.11.28)(*)</td>
<td><a href="https://codeforces.com/gym/100299/problem/E" target="_blank" rel="noopener">PE</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101620/problem/I" target="_blank" rel="noopener">LI</a></td>
<td><a href="#LI">✔</a>(2020.10.13)</td>
<td><a href="https://codeforces.com/gym/101221/problem/I" target="_blank" rel="noopener">AI</a></td>
<td><a href="#AI">✔</a>(2020.11.16)(*)</td>
<td><a href="https://codeforces.com/gym/101142/problem/J" target="_blank" rel="noopener">RJ</a></td>
<td><a href="#RJ">✔</a>(2020.10.14)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100801/problem/F" target="_blank" rel="noopener">SF</a></td>
<td><a href="#SF">✔</a>(2020.11.13)(*)</td>
<td><a href="https://codeforces.com/gym/100851/problem/I" target="_blank" rel="noopener">II</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101190/problem/G" target="_blank" rel="noopener">HG</a></td>
<td><a href="#HG">✔</a>(2020.12.8)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101142/problem/E" target="_blank" rel="noopener">RE</a></td>
<td><a href="#RE">✔</a>(2020.10.12)</td>
<td><a href="https://codeforces.com/gym/101620/problem/L" target="_blank" rel="noopener">LL</a></td>
<td><a href="#LL">✔</a>(2020.10.13)</td>
<td><a href="https://codeforces.com/gym/100543/problem/A" target="_blank" rel="noopener">OA</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/102511/problem/B" target="_blank" rel="noopener">FB</a></td>
<td><a href="#FB">✔</a>(2020.10.13)</td>
<td><a href="https://codeforces.com/gym/101612/problem/D" target="_blank" rel="noopener">QD</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101471/problem/A" target="_blank" rel="noopener">DA</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100531/problem/C" target="_blank" rel="noopener">TC</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101221/problem/E" target="_blank" rel="noopener">AE</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101242/problem/B" target="_blank" rel="noopener">CB</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101630/problem/F" target="_blank" rel="noopener">GF</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101221/problem/G" target="_blank" rel="noopener">AG</a></td>
<td><a href="#AG">✔</a>(2020.11.17)(*)</td>
<td><a href="https://codeforces.com/gym/100553/problem/C" target="_blank" rel="noopener">JC</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100299/problem/A" target="_blank" rel="noopener">PA</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/100531/problem/H" target="_blank" rel="noopener">TH</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/102482/problem/H" target="_blank" rel="noopener">EH</a></td>
<td><a href="#EH">✔</a>(2020.11.16)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101221/problem/J" target="_blank" rel="noopener">AJ</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/100531/problem/K" target="_blank" rel="noopener">TK</a></td>
<td><a href="#TK">✔</a>(2020.10.26)</td>
<td><a href="https://codeforces.com/gym/102482/problem/I" target="_blank" rel="noopener">EI</a></td>
<td><a href="#EI">✔</a>(2020.10.26)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100269/problem/L" target="_blank" rel="noopener">UL</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101221/problem/F" target="_blank" rel="noopener">AF</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/100801/problem/K" target="_blank" rel="noopener">SK</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101239/problem/H" target="_blank" rel="noopener">BH</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101142/problem/D" target="_blank" rel="noopener">RD</a></td>
<td><a href="#RD">✔</a>(2020.11.17)(*)</td>
<td><a href="https://codeforces.com/gym/100543/problem/K" target="_blank" rel="noopener">OK</a></td>
<td><a href="#OK">✔</a>(2020.11.13)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/102511/problem/C" target="_blank" rel="noopener">FC</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/100553/problem/D" target="_blank" rel="noopener">JD</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/100543/problem/E" target="_blank" rel="noopener">OE</a></td>
<td><a href="#OE">✔</a>(2020.11.20)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100531/problem/F" target="_blank" rel="noopener">TF</a></td>
<td><a href="#TF">✔</a>(2020.10.27)</td>
<td><a href="https://codeforces.com/gym/102511/problem/F" target="_blank" rel="noopener">FF</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101471/problem/D" target="_blank" rel="noopener">DD</a></td>
<td><a href="#DD">✔</a>(2020.10.23)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101242/problem/J" target="_blank" rel="noopener">CJ</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101190/problem/K" target="_blank" rel="noopener">HK</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101173/problem/J" target="_blank" rel="noopener">MJ</a></td>
<td><a href="#MJ">✔</a>(2020.11.3)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/102511/problem/G" target="_blank" rel="noopener">FG</a></td>
<td><a href="#FG">✔</a>(2020.10.13)</td>
<td><a href="https://codeforces.com/gym/101630/problem/L" target="_blank" rel="noopener">GL</a></td>
<td><a href="#GL">✔</a>(2020.11.23)(*)</td>
<td><a href="https://codeforces.com/gym/101221/problem/L" target="_blank" rel="noopener">AL</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/102511/problem/I" target="_blank" rel="noopener">FI</a></td>
<td><a href="#FI">✔</a>(2020.11.21)(*)</td>
<td><a href="https://codeforces.com/gym/100851/problem/C" target="_blank" rel="noopener">IC</a></td>
<td><a href="#IC">✔</a>(2020.11.25)(*)</td>
<td><a href="https://codeforces.com/gym/101612/problem/C" target="_blank" rel="noopener">QC</a></td>
<td><a href="#QC">✔</a>(2020.11.20)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101173/problem/D" target="_blank" rel="noopener">MD</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/100543/problem/J" target="_blank" rel="noopener">OJ</a></td>
<td><a href="#OJ">✔</a>(2020.10.12)</td>
<td><a href="https://codeforces.com/gym/101190/problem/I" target="_blank" rel="noopener">HI</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100307/problem/K" target="_blank" rel="noopener">KK</a></td>
<td><a href="#KK">✔</a>(2020.12.8)(*)</td>
<td><a href="https://codeforces.com/gym/100553/problem/H" target="_blank" rel="noopener">JH</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/100543/problem/B" target="_blank" rel="noopener">OB</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101239/problem/K" target="_blank" rel="noopener">BK</a></td>
<td></td>
<td><a href="https://codeforces.com/gym/101630/problem/J" target="_blank" rel="noopener">GJ</a></td>
<td><a href="#GJ">✔</a>(2020.10.20)</td>
<td><a href="https://codeforces.com/gym/100307/problem/E" target="_blank" rel="noopener">KE</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101242/problem/A" target="_blank" rel="noopener">CA</a></td>
<td><a href="#CA">✔</a>(2020.11.11)(*)</td>
<td><a href="https://codeforces.com/gym/100851/problem/K" target="_blank" rel="noopener">IK</a></td>
<td><a href="#IK">✔</a>(2020.10.22)</td>
<td><a href="https://codeforces.com/gym/101620/problem/E" target="_blank" rel="noopener">LE</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101142/problem/I" target="_blank" rel="noopener">RI</a></td>
<td><a href="#RI">✔</a>(2020.10.23)</td>
<td><a href="https://codeforces.com/gym/101620/problem/K" target="_blank" rel="noopener">LK</a></td>
<td><a href="#LK">✔</a>(2020.10.25)</td>
<td><a href="https://codeforces.com/gym/100299/problem/D" target="_blank" rel="noopener">PD</a></td>
<td><a href="#PD">✔</a>(2020.11.10)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/100553/problem/E" target="_blank" rel="noopener">JE</a></td>
<td><a href="#JE">✔</a>(2020.11.29)(*)</td>
<td><a href="https://codeforces.com/gym/101620/problem/B" target="_blank" rel="noopener">LB</a></td>
<td><a href="#LB">✔</a>(2020.12.7)(*)</td>
<td><a href="https://codeforces.com/gym/101190/problem/B" target="_blank" rel="noopener">HB</a></td>
<td><a href="#HB">✔</a>(2020.11.18)(*)</td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101239/problem/L" target="_blank" rel="noopener">BL</a></td>
<td><a href="#BL">✔</a>(2020.10.26)</td>
<td><a href="https://codeforces.com/gym/101142/problem/G" target="_blank" rel="noopener">RG</a></td>
<td><a href="#RG">✔</a>(2020.10.14)</td>
<td><a href="https://codeforces.com/gym/101221/problem/H" target="_blank" rel="noopener">AH</a></td>
<td></td>
</tr>
<tr>
<td><a href="https://codeforces.com/gym/101221/problem/K" target="_blank" rel="noopener">AK</a></td>
<td><a href="#AK">✔</a>(2020.10.12)</td>
<td><a href="https://codeforces.com/gym/101630/problem/G" target="_blank" rel="noopener">GG</a></td>
<td><a href="#GG">✔</a>(2020.10.28)(*)</td>
<td><a href="https://codeforces.com/gym/100553/problem/G" target="_blank" rel="noopener">JG</a></td>
<td><a href="#JG">✔</a>(2020.11.9)(*)</td>
</tr>
</tbody>
</table>
</div>
<p>表格及链接来自<a href="https://www.cnblogs.com/PinkRabbit/p/IOI2021Homework1.html" target="_blank" rel="noopener">兔队</a>。</p>
<p><strong>题目编号规则：</strong>由两个字母组成，第一个字母表示该题的来源（详见兔队的博客）。第二个字母表示该题在其所在比赛中的题目编号。</p>
<hr>
<p>以下部分<del>按照做题的时间顺序</del>乱序更新题解。</p>
<p><del>鸽了鸽了，心情好了会补题解</del></p>
<h1 id="AK"><a href="#AK" class="headerlink" title="AK"></a><div id="AK">AK</div></h1><h2 id="题目大意："><a href="#题目大意：" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个大小为 $n$ 的环和 $k$ 条线段，要求使用最少的线段覆盖环。</p>
<p>$n,k\le 10^6$。</p>
<h2 id="题解："><a href="#题解：" class="headerlink" title="题解："></a>题解：</h2><p>记 $A_{i,j}$ 表示位置 $j$ <strong>及其之前</strong>开始经过 $2^i$ 轮能到达的最右端点。</p>
<p>上面加粗部分并不影响答案，但是能够使 $A_{\star,j}$ 单调不降。</p>
<p>考虑倍增得到 $A_{i,j}$，由于记录的是 $j$ 及其之前的答案，所以也只需要前缀最大值即可。</p>
<p>最后倍增答案，判断是否合法即可。</p>
<p>时空复杂度 $O(n\log n)$。</p>
<h2 id="Code："><a href="#Code：" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c+=">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,k,ans=INT_MAX;
const int N=2e6+6;
int _R[N],sta[N],h,t;
int A[21][N],f[N],g[N];
void work(int*A,int*B){
    for(int i=1,r=1,mx=0;i&lt;=2*n;++i){
        while(r&lt;=A[i]+1&amp;&amp;r&lt;=2*n)mx=max(mx,B[r++]);
        A[i]=mx;
    }
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n&gt;&gt;k;
    for(int i=1;i&lt;=k;++i){
        int l,r;
        cin&gt;&gt;l&gt;&gt;r;
        if(l&gt;r)r+=n;
        _R[l]=max(_R[l],r);
        _R[l+n]=max(_R[l],r+n);
    }
    for(int i=1;i&lt;=2*n;++i)A[0][i]=max(A[0][i-1],_R[i]);
    for(int i=1;i&lt;21;++i){
        memcpy(A[i],A[i-1],sizeof*A);
        work(A[i],A[i-1]);
    }
    for(int i=1;i&lt;=n;++i)f[i]=i;
    int ans=0;
    for(int i=20;~i;--i){
        memcpy(g,f,sizeof g);
        work(f,A[i]);
        bool ok=0;
        for(int j=1;j&lt;=2*n&amp;&amp;!ok;++j)if(f[j]-j&gt;=n)ok=1;
        if(ok)memcpy(f,g,sizeof f);else ans|=1&lt;&lt;i;
    }
    if(++ans&gt;1e6)cout&lt;&lt;&quot;impossible&quot;;
    else cout&lt;&lt;ans&lt;&lt;&#39;\n&#39;;
    return 0;
}
</code></pre>
<hr>
<h1 id="RE"><a href="#RE" class="headerlink" title="RE"></a><div id="RE">RE</div></h1><h2 id="题目大意：-1"><a href="#题目大意：-1" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一段长度为 $l$ 的文字，和一个 $n\times m$ 的网格图。网格图上每个格子为 <code>.</code> 或 <code>X</code>。</p>
<p>你需要从文字中选一段子串，然后选择网格图上的任意一个点 $(x,y)$ 作为起点。</p>
<p>要求：依次遍历选出的子串，遇到 <code>l,r,u,d</code> 字符时，分别使你当前所在的位置往左、右、上、下移动一格。并且<strong>恰好</strong>到达所有的 <code>X</code> 且不能到达 <code>.</code>（包括起点）。</p>
<p>问是否可行，如果可行输出你选的子串区间。</p>
<p>$l,n\times m\leq 10^5$。</p>
<h2 id="题解：-1"><a href="#题解：-1" class="headerlink" title="题解："></a>题解：</h2><p>我们先不管起点的位置，只需要满足你走到的点和图“形状相同”即可。</p>
<p>显然要完美覆盖这个图，经过的点的个数得和那张图上 <code>X</code> 的个数相等。</p>
<p>这样的子串区间显然有单调性。</p>
<p>我们用双指针维护当前选的子串区间，不断移动右指针直到走过的点的个数和 <code>X</code> 的个数相等，然后需要快速判断是否相等就好了。若合法则输出答案，否则左端点向右移继续当前过程。</p>
<p>那么问题在于如何快速判断是否相等。</p>
<p>我们可以取经过的点的最小的横、纵坐标作为基准（这个可以轻松使用 STL 在 $O(l\log l)$ 内维护），将点与图片对其。然后逐行判断即可。判断的时候可以采用 hash 的方式。</p>
<p>注意到 $nm\leq 10^5$，因此必然存在一维小于 $\sqrt{100000}$，我们枚举小的那一维判断即可。</p>
<p>时间复杂度 $O(l\log l+l\sqrt{nm})$。</p>
<h2 id="Code：-1"><a href="#Code：-1" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
typedef pair&lt;int,int&gt;PII;
const int N=2e5+5;
mt19937 mt(time(0)+(size_t)new char);
string s,A[N],tmp[N];
inline PII&amp;operator+=(PII&amp;a,const PII&amp;b){
    a.first+=b.first,a.second+=b.second;
    return a;
}
int len,n,m;
PII ds[2004];
map&lt;PII,int&gt;tot;
int cnt;
char ch[N];
int k,pos[N];
multiset&lt;int&gt;hang,lie;
template&lt;const int md&gt;
struct Hasher{
    int base,_[N];
    Hasher(){
        base=mt()%500000+100000;
        for(int i=*_=1;i&lt;=200000;++i)_[i]=(LL)_[i-1]*base%md;
    }
    inline int get(int wg){return _[wg];}
    inline void upd(int&amp;a){a+=a&gt;&gt;31&amp;md;}
    inline void add(int&amp;a,int b){upd(a+=_[b]-md);}
    inline void del(int&amp;a,int b){upd(a-=_[b]);}
    inline int shr(int a,int b){return(LL)a*_[b]%md;}
};
Hasher&lt;1004535809&gt;hx1;
Hasher&lt;1000000009&gt;hx2;
int _h1[N],_h2[N],P_h1[500],P_h2[500];
void work_picture(){
    int LX=1e5,LY=1e5;
    for(int i=0;i&lt;n;++i)
    for(int j=0;j&lt;m;++j)if(A[i][j]==&#39;X&#39;)LX=min(LX,i),LY=min(LY,j);
    for(int i=LX;i&lt;n;++i)
    for(int j=LY;j&lt;m;++j)
    if(A[i][j]==&#39;X&#39;)hx1.add(P_h1[i-LX],j-LY),hx2.add(P_h2[i-LX],j-LY);
}
int main(){
    freopen(&quot;easy.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;easy.out&quot;,&quot;w&quot;,stdout);
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;len,getline(cin,s),getline(cin,s),cin&gt;&gt;n&gt;&gt;m;
    s=&quot; &quot;+s;
    for(int i=1;i&lt;=len;++i)if(s[i]==&#39;l&#39;||s[i]==&#39;r&#39;||s[i]==&#39;u&#39;||s[i]==&#39;d&#39;)
    ch[++k]=s[i],pos[k]=i;
    for(int i=0;i&lt;n;++i)cin&gt;&gt;tmp[i];
    int tot_pic=0;
    for(int i=0;i&lt;n;++i)for(char c:tmp[i])tot_pic+=c==&#39;X&#39;;
    ds[&#39;l&#39;]=make_pair(0,-1);
    ds[&#39;r&#39;]=make_pair(0,1);
    ds[&#39;u&#39;]=make_pair(-1,0);
    ds[&#39;d&#39;]=make_pair(1,0);
    if(n&gt;m){
        for(int i=0;i&lt;n;++i)
        for(int j=0;j&lt;m;++j)A[j]+=tmp[i][j];
        swap(ds[&#39;l&#39;],ds[&#39;u&#39;]);
        swap(ds[&#39;r&#39;],ds[&#39;d&#39;]);
        swap(n,m);
    }else for(int i=0;i&lt;n;++i)A[i]=tmp[i];
    work_picture();
    PII _begin=make_pair(100000,100000),_end=_begin;
    ++tot[_begin];
    _h1[100000]=hx1.get(1e5);
    _h2[100000]=hx2.get(1e5);
    hang.insert(100000),lie.insert(100000);
    cnt=1;
    for(int i=1,_i=1;i&lt;=k;++i){
        _end+=ds[(int)ch[i]];
        if(!tot[_end]++){
            ++cnt;
            hx1.add(_h1[_end.first],_end.second);
            hx2.add(_h2[_end.first],_end.second);
            hang.insert(_end.first),lie.insert(_end.second);
        }
        if(cnt==tot_pic){
            int lx=*hang.begin(),ly=*lie.begin();
            bool ok=1;
            for(int i=0;i&lt;n&amp;&amp;ok;++i){
                int h1=_h1[lx+i],h2=_h2[lx+i];
                if(!(h1==hx1.shr(P_h1[i],ly)&amp;&amp;h2==hx2.shr(P_h2[i],ly)))ok=0;
            }
            if(ok){
                cout&lt;&lt;&quot;YES\n&quot;&lt;&lt;pos[_i]&lt;&lt;&#39; &#39;&lt;&lt;pos[i]&lt;&lt;&#39;\n&#39;;
                return 0;
            }
            while(cnt==tot_pic){
                if(!--tot[_begin]){
                    --cnt;
                    hx1.del(_h1[_begin.first],_begin.second);
                    hx2.del(_h2[_begin.first],_begin.second);
                    hang.erase(hang.find(_begin.first));
                    lie.erase(lie.find(_begin.second));
                }
                _begin+=ds[(int)ch[_i++]];
            }
        }
    }
    cout&lt;&lt;&quot;NO\n&quot;;
    return 0;
}
</code></pre>
<hr>
<h1 id="OJ"><a href="#OJ" class="headerlink" title="OJ"></a><div id="OJ">OJ</div></h1><h2 id="题目大意：-2"><a href="#题目大意：-2" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定 $n$ 个点 $m$ 条边，边带权值 $w$，保证无重边。</p>
<p>有 $q$ 个询问，每次给出 $l,h$，要求你只能使用权值在 $[l,h]$ 的边，且让尽可能多的点连通，<strong>在此基础上</strong>使用到的边的边权最少。求最少边权。</p>
<p>多测，强制在线。</p>
<p>$1\leq n\leq 10^3$，$1\leq m\leq 10^5$，$1\leq q,w,l,h\leq 10^6$。</p>
<h2 id="题解：-2"><a href="#题解：-2" class="headerlink" title="题解："></a>题解：</h2><p>对每个询问，我们贪心地选择最小的边是最优的。这个过程同 Kruskal。加到不能加为止，用到的边的权值和就是最小的。</p>
<p>我们先不考虑上界，仅考虑下界。那么这就是一个经典的问题，可以用贪心求解。</p>
<p>将边权从大到小排序，按顺序把边插入。插入一条边的时候，若两点原来不连通，则直接添加。若两点原来连通，则一定形成了一个环，将环上边权最大的那条边删掉用新边替代即可。证明略。</p>
<p>可以用 LCT 来维护。时间复杂度 $O(m\log n)$。</p>
<p>那么现在有了上界的限制。我们只需要在只有下界限制求出的图中，将边权超过上界的边删掉即为答案。</p>
<p>原因：由贪心过程可知，若删掉那些边后，存在一条在范围内的边能使答案更优，则这条边一定能替换掉另一条边权比它大的边使只有下界时的答案更优。所以并不存在这样的边。</p>
<p>于是我们只需要在 LCT 的过程中，用权值线段树维护使用的边的边权和。查询时直接在线段树上区间查询即可。</p>
<p>由于本题强制在线，所以需要使用可持久化线段树。</p>
<p>时间复杂度 $O(m\log n+q\log m)$。空间复杂度 $O(m\log m)$。</p>
<h2 id="Code：-2"><a href="#Code：-2" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
typedef long long LL;
using namespace std;
const int N=2e5+6;
int n,m,q;
namespace lct{
    int fa[N],ch[N][2],tag[N];
    pair&lt;int,int&gt;mx[N],val[N];
    inline int ckr(int x,const int p=1){return ch[fa[x]][p]==x;}
    inline int isroot(int x){return!(ckr(x)||ckr(x,0));}
    inline void flip(int x){std::swap(ch[x][0],ch[x][1]),tag[x]^=1;}
    inline void update(int x){mx[x]=std::max(val[x],std::max(mx[ch[x][0]],mx[ch[x][1]]));}
    inline void pushdown(int x){if(tag[x]){tag[x]=0;if(ch[x][0])flip(ch[x][0]);if(ch[x][1])flip(ch[x][1]);}}
    inline void rotate(int x){
        int y=fa[x],z=fa[y],k=ckr(x);
        if(!isroot(y))ch[z][ckr(y)]=x;
        fa[x]=z,fa[y]=x,fa[ch[x][!k]]=y;
        ch[y][k]=ch[x][!k],ch[x][!k]=y;
        update(y);
    }
    inline void splay(int x){
        static int sta[N],top;sta[top=1]=x;
        for(int y=x;!isroot(y);sta[++top]=y=fa[y]);
        while(top)pushdown(sta[top--]);
        for(;!isroot(x);rotate(x))
        if(!isroot(fa[x]))rotate((ckr(x)^ckr(fa[x]))?x:fa[x]);
        update(x);
    }
    inline void access(int x){for(int t=0;x;ch[x][1]=t,t=x,x=fa[x])splay(x);}
    inline void makeroot(int x){access(x),splay(x),flip(x);}
    inline void split(int x,int y){makeroot(x),access(y),splay(y);}
    inline int findroot(int x){access(x);for(splay(x);ch[x][0];x=ch[x][0]);splay(x);return x;}
    inline void link(int x,int y){makeroot(x),fa[x]=y;}
    inline void cut(int x,int y){makeroot(x),access(y),splay(y),ch[y][0]=fa[x]=0,update(y);}
    inline pair&lt;int,int&gt;query(int x,int y){split(x,y);return mx[y];}
    inline int connect(int x,int y){return findroot(x)==findroot(y);}
}
namespace sgt{
    LL sum[N*32];int ls[N*32],rs[N*32],nod;
    void add(int&amp;o,int pre,int l,int r,const int&amp;pos,const int&amp;v){
        o=++nod,ls[o]=ls[pre],rs[o]=rs[pre],sum[o]=sum[pre]+v;
        if(l&lt;r){
            const int mid=(l+r)/2;
            if(pos&lt;=mid)add(ls[o],ls[pre],l,mid,pos,v);
            else add(rs[o],rs[pre],mid+1,r,pos,v);
        }
    }
    LL query(int o,int l,int r,const int&amp;L,const int&amp;R){
        if(!o)return 0;
        if(L&lt;=l&amp;&amp;r&lt;=R)return sum[o];
        LL res=0;
        const int mid=(l+r)/2;
        if(L&lt;=mid)res=query(ls[o],l,mid,L,R);
        if(mid&lt;R)res+=query(rs[o],mid+1,r,L,R);
        return res;
    }
}
struct EDGE{
    int u,v,w;
    inline bool operator&lt;(const EDGE&amp;rhs)const{return w&lt;rhs.w;}
}e[N];
int rt[N];
void addedge(int id,int&amp;rt){
    int u=e[id].u,v=e[id].v,w=e[id].w;
    int pos=lower_bound(e+1,e+m+1,(EDGE){0,0,w})-e;
    sgt::add(rt,rt,1,m,pos,w);
    if(lct::connect(u,v)){
        pair&lt;int,int&gt;dd=lct::query(u,v);
        pos=lower_bound(e+1,e+m+1,(EDGE){0,0,dd.first})-e;
        sgt::add(rt,rt,1,m,pos,-dd.first);
        int uu=e[dd.second].u,vv=e[dd.second].v;
        lct::cut(uu,dd.second+n),lct::cut(vv,dd.second+n);
    }
    lct::val[n+id]=lct::mx[n+id]=make_pair(w,id);
    lct::link(u,n+id),lct::link(v,n+id);
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    int T;
    for(cin&gt;&gt;T;T--;){
        cin&gt;&gt;n&gt;&gt;m;
        for(int i=1;i&lt;=m;++i)
        cin&gt;&gt;e[i].u&gt;&gt;e[i].v&gt;&gt;e[i].w;
        sort(e+1,e+m+1);
        for(int i=m;i;--i)addedge(i,rt[i]=rt[i+1]);
        for(int i=2;i&lt;=m;++i)
        if(e[i].w==e[i-1].w)rt[i]=rt[i-1];
        cin&gt;&gt;q;
        LL ans=0;
        while(q--){
            LL l,r;
            cin&gt;&gt;l&gt;&gt;r;
            l-=ans,r-=ans;
            assert(1&lt;=l&amp;&amp;l&lt;=r&amp;&amp;r&lt;=1000000);
            int pos=lower_bound(e+1,e+m+1,(EDGE){0,0,(int)l})-e;
            int R=upper_bound(e+1,e+m+1,(EDGE){0,0,(int)r})-e-1;
            ans=sgt::query(rt[pos],1,m,1,R);
            cout&lt;&lt;ans&lt;&lt;&#39;\n&#39;;
        }
        for(int i=1;i&lt;=n+m;++i)
        lct::fa[i]=lct::ch[i][0]=lct::ch[i][1]=lct::tag[i]=0,
        lct::mx[i]=lct::val[i]=make_pair(0,0);
        for(int i=1;i&lt;=m;++i)rt[i]=0;
        sgt::nod=0;
    }
    return 0;
}
</code></pre>
<hr>
<h1 id="LI"><a href="#LI" class="headerlink" title="LI"></a><div id="LI">LI</div></h1><h2 id="题目大意：-3"><a href="#题目大意：-3" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个长度为 $n$ 的排列 $p$。$m$ 次询问，每次询问给出 $x,y$，求包含 $p_x,p_y$ 的最短的值域连续段。输出两个端点。</p>
<h2 id="题解：-3"><a href="#题解：-3" class="headerlink" title="题解："></a>题解：</h2><p>析合树模板题。</p>
<p>建出析合树，每次询问的时候查询 $p_x$ 和 $p_y$ 在析合树上的 LCA。</p>
<p>若 LCA 为析点或 $x=y$，则 LCA 代表的这段区间就是答案。</p>
<p>若 LCA 为合点且 $x\neq y$，我们要找 LCA 的儿子中最短的包含 $p_x,p_y$ 的段。分别找到 $p_x,p_y$ 对应的儿子结点即可。</p>
<p>建析合树的过程使用较易理解的做法，时间复杂度 $O(n\log n)$，空间复杂度 $O(n)$。</p>
<p>有关析合树的参考资料：</p>
<p><a href="https://oi-wiki.org/ds/divide-combine/" target="_blank" rel="noopener">OI-Wiki</a></p>
<p><a href="https://yhx-12243.github.io/OI-transit/records/cf526F.html" target="_blank" rel="noopener">yhx 的博客</a></p>
<h2 id="Code：-3"><a href="#Code：-3" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=2e5+6;
int n,p[N],m,psn[N];
namespace rmq{
    int mn[N&lt;&lt;2],mx[N&lt;&lt;2];
    void build(int l,int r,int o){
        if(l==r)mn[o]=mx[o]=psn[l];else{
            const int mid=(l+r)/2;
            build(l,mid,o&lt;&lt;1),build(mid+1,r,o&lt;&lt;1|1);
            mn[o]=min(mn[o&lt;&lt;1],mn[o&lt;&lt;1|1]);
            mx[o]=max(mx[o&lt;&lt;1],mx[o&lt;&lt;1|1]);
        }
    }
    int _min(const int&amp;L,const int&amp;R,int l=1,int r=n,int o=1){
        if(L&lt;=l&amp;&amp;r&lt;=R)return mn[o];
        const int mid=(l+r)/2;
        int res=1e9;
        if(L&lt;=mid)res=_min(L,R,l,mid,o&lt;&lt;1);
        if(mid&lt;R)res=min(res,_min(L,R,mid+1,r,o&lt;&lt;1|1));
        return res;
    }
    int _max(const int&amp;L,const int&amp;R,int l=1,int r=n,int o=1){
        if(L&lt;=l&amp;&amp;r&lt;=R)return mx[o];
        const int mid=(l+r)/2;
        int res=0;
        if(L&lt;=mid)res=_max(L,R,l,mid,o&lt;&lt;1);
        if(mid&lt;R)res=max(res,_max(L,R,mid+1,r,o&lt;&lt;1|1));
        return res;
    }
    void init(){build(1,n,1);}
}
namespace sgt{
    pair&lt;int,int&gt;d[N&lt;&lt;2];
    int tag[N&lt;&lt;2];
    inline void pushdown(int o){
        if(int&amp;x=tag[o]){
            d[o&lt;&lt;1].first+=x,d[o&lt;&lt;1|1].first+=x;
            tag[o&lt;&lt;1]+=x,tag[o&lt;&lt;1|1]+=x;
            x=0;
        }
    }
    void add(int l,int r,int o,const int&amp;L,const int&amp;R,const int&amp;v){
        if(d[o].first&gt;=1000000000)return;
        if(L&lt;=l&amp;&amp;r&lt;=R){
            d[o].first+=v;
            tag[o]+=v;
        }else{
            pushdown(o);
            const int mid=(l+r)/2;
            if(L&lt;=mid)add(l,mid,o&lt;&lt;1,L,R,v);
            if(mid&lt;R)add(mid+1,r,o&lt;&lt;1|1,L,R,v);
            if(d[o&lt;&lt;1].first&lt;d[o&lt;&lt;1|1].first)d[o]=d[o&lt;&lt;1];
            else d[o]=d[o&lt;&lt;1|1];
        }
    }
    void modify(int l,int r,int o,const int&amp;pos,const pair&lt;int,int&gt;&amp;v){
        if(l==r)d[o]=v;else{
            pushdown(o);
            const int mid=(l+r)/2;
            if(pos&lt;=mid)modify(l,mid,o&lt;&lt;1,pos,v);
            else modify(mid+1,r,o&lt;&lt;1|1,pos,v);
            if(d[o&lt;&lt;1].first&lt;d[o&lt;&lt;1|1].first)d[o]=d[o&lt;&lt;1];
            else d[o]=d[o&lt;&lt;1|1];
        }
    }
}
namespace xht{
    int head[N],cnt;
    struct edge{
        int to,nxt;
    }e[N];
    inline void addedge(int u,int v){e[++cnt]=(edge){v,head[u]},head[u]=cnt;}
    struct node{
        int l,r;
        bool X;
        inline int length(){return r-l;}
    }a[N];
    int nod,sta[N],top,tmax,tmin,rt;
    pair&lt;int,int&gt;_max[N],_min[N];
    void insert(int id){
        int val=id;
        if(!top){
            sta[++top]=id;
            sgt::modify(1,n,1,top,make_pair(0,top));
            if(!tmax||_max[tmax].first!=a[id].r)_max[++tmax]=make_pair(a[id].r,top);
            if(!tmin||_min[tmin].first!=a[id].l)_min[++tmin]=make_pair(a[id].l,top);
            return;
        }
        while(top){
            if(a[sta[top]].X&amp;&amp;max(a[sta[top]].r,a[id].r)-min(a[sta[top]].l,a[id].l)==a[sta[top]].length()+a[id].length()){
                sgt::modify(1,n,1,top,make_pair(1000000000,0));
                int x=sta[top--];
                a[x].r=max(a[x].r,a[id].r),a[x].l=min(a[x].l,a[id].l);
                addedge(x,id);
                id=x;
            }else break;
        }
        --sgt::tag[1],--sgt::d[1].first;
        int pre=top;
        while(tmax&amp;&amp;_max[tmax].first&lt;val){
            sgt::add(1,n,1,_max[tmax].second,pre,val-_max[tmax].first);
            pre=_max[tmax].second-1;
            --tmax;
        }
        if(pre&lt;top)
        _max[++tmax]=make_pair(val,pre+1);
        pre=top;
        while(tmin&amp;&amp;_min[tmin].first&gt;val){
            sgt::add(1,n,1,_min[tmin].second,pre,_min[tmin].first-val);
            pre=_min[tmin].second-1;
            --tmin;
        }
        if(pre&lt;top)
        _min[++tmin]=make_pair(val,pre+1);
        while(top){
            pair&lt;int,int&gt;zd=sgt::d[1];
            if(zd.first)break;
            if(zd.second==top&amp;&amp;a[sta[top]].X==0){
                int x=sta[top];
                if((psn[a[x].l]&lt;psn[a[x].r]&amp;&amp;a[x].r&lt;a[id].l)||(psn[a[x].l]&gt;psn[a[x].r]&amp;&amp;a[x].r&gt;a[id].l)){
                    sgt::modify(1,n,1,top,make_pair(1000000000,0));
                    addedge(x,id);
                    a[x].l=min(a[x].l,a[id].l);
                    a[x].r=max(a[x].r,a[id].r);
                    --top;
                    id=x;
                    continue;
                }
            }
            int nw=++nod;
            if(zd.second&lt;top)a[nw].X=1;
            a[nw].r=a[id].r,a[nw].l=a[id].l;
            for(int i=zd.second;i&lt;=top;++i){
                sgt::modify(1,n,1,i,make_pair(1000000000,0));
                a[nw].r=max(a[nw].r,a[sta[i]].r);
                a[nw].l=min(a[nw].l,a[sta[i]].l);
                addedge(nw,sta[i]);
            }
            addedge(nw,id);
            top=zd.second-1;
            id=nw;
        }
        while(tmax&amp;&amp;_max[tmax].second&gt;top)--tmax;
        while(tmin&amp;&amp;_min[tmin].second&gt;top)--tmin;
        sta[++top]=id;
        sgt::modify(1,n,1,top,make_pair(0,top));
        if(!tmax||_max[tmax].first!=a[id].r)_max[++tmax]=make_pair(a[id].r,top);
        if(!tmin||_min[tmin].first!=a[id].l)_min[++tmin]=make_pair(a[id].l,top);
    }
    void build(){
        nod=n;
        for(int i=1;i&lt;N&lt;&lt;2;++i)sgt::d[i]=make_pair(1000000000,0);
        for(int i=1;i&lt;=n;++i)a[i]=(node){i,i,0};
        for(int i=1;i&lt;=n;++i)
        insert(p[i]);
        rt=sta[1];
    }
    int fa[N],dep[N],Top[N],sz[N],son[N];
    void dfs(int now){
        sz[now]=1;
        for(int i=head[now];i;i=e[i].nxt){
            fa[e[i].to]=now,dep[e[i].to]=dep[now]+1;
            dfs(e[i].to);
            sz[now]+=sz[e[i].to];
            if(!son[now]||sz[son[now]]&lt;sz[e[i].to])
            son[now]=e[i].to;
        }
    }
    void dfs2(int now){
        if(son[now])Top[son[now]]=Top[now],dfs2(son[now]);
        for(int i=head[now];i;i=e[i].nxt)if(e[i].to!=son[now])
        dfs2(Top[e[i].to]=e[i].to);
    }
    inline int LCA(int x,int y){
        while(Top[x]!=Top[y])if(dep[Top[x]]&gt;dep[Top[y]])x=fa[Top[x]];else y=fa[Top[y]];
        return dep[x]&lt;dep[y]?x:y;
    }
    inline int get(int u,int v){
        while(Top[u]!=Top[v]){
            if(fa[Top[v]]==u)return Top[v];
            v=fa[Top[v]];
        }
        return son[u];
    }
    void init(){
        dep[rt]=1;
        dfs(rt),dfs2(Top[rt]=rt);
    }
    void query(int l,int r){
        int t=LCA(l,r);
        if(a[t].X||l==r){
            cout&lt;&lt;rmq::_min(a[t].l,a[t].r)&lt;&lt;&#39; &#39;&lt;&lt;rmq::_max(a[t].l,a[t].r)&lt;&lt;&#39;\n&#39;;
            return;
        }
        int ls=get(t,l),rs=get(t,r);
        int R=max(a[ls].r,a[rs].r),L=min(a[ls].l,a[rs].l);
        cout&lt;&lt;rmq::_min(L,R)&lt;&lt;&#39; &#39;&lt;&lt;rmq::_max(L,R)&lt;&lt;&#39;\n&#39;;
    }
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i)cin&gt;&gt;p[i],psn[p[i]]=i;
    rmq::init();
    xht::build();
    xht::init();
    for(cin&gt;&gt;m;m--;){
        int l,r;
        cin&gt;&gt;l&gt;&gt;r;
        xht::query(p[l],p[r]);
    }
    return 0;
}
</code></pre>
<h1 id="FB"><a href="#FB" class="headerlink" title="FB"></a><div id="FB">FB</div></h1><h2 id="题目大意：-4"><a href="#题目大意：-4" class="headerlink" title="题目大意："></a>题目大意：</h2><p>你要修一座拱桥。桥的高度为 $h$。给出 $n$ 个点 $(x_1,y_1),(x_2,y_2),\ldots,(x_n,y_n)$，将所有相邻两个点连起来就是地面。</p>
<p>你需要修若干条柱子，只能在给定的点对应的横坐标处修，在第 $i$ 个点处修的柱子的高度为 $h-x_i$。第 $1$ 个和第 $n$ 个点处必须修柱子。</p>
<p>你还需要在修的柱子之间造拱，拱是一个半圆形，直径为两个柱子的距离，恰好和桥面相切。</p>
<p>拱不能和地面相交，可以相切。</p>
<p>假设你修了 $k$ 条柱子，高度为 $h_1,h_2,\ldots,h_k$，其中 $k-1$ 个拱的直径为 $d_1,d_2,\ldots,d_{k-1}$。</p>
<p>给定参数 $\alpha,\beta$，要求最小化：</p>
<script type="math/tex; mode=display">
\alpha\cdot\sum_{i=1}^k h_i +\beta\cdot\sum_{i=1}^{k-1}d_i^2</script><p>无合法方案输出 <code>impossible</code>。</p>
<p>$1\leq n\leq 10^4$。</p>
<h2 id="题解：-4"><a href="#题解：-4" class="headerlink" title="题解："></a>题解：</h2><p>考虑动态规划。</p>
<p>记 $f_i$ 表示点 $i$ 之前都修完了，且 $i$ 处修柱子的最小花费。</p>
<p>转移时枚举前一个柱子的位置 $j$，然后加上 $i$ 的柱子和 $i,j$ 之间的距离的贡献，取 $\min$ 即可。</p>
<p>由于题目有限制条件，因此要判断拱和每个点是否相交。加上判断的时间，复杂度为 $O(n^3)$。</p>
<p>我们对于点 $(a,b)$，拱的<strong>半径</strong>为 $r$，当前考虑建柱子的的点为 $(x,y)$，考虑拱和两个点不相交需要满足的条件。</p>
<p>两个最基本的条件是：$a+r&gt;h$，$x+r&gt;h$。</p>
<p>半圆圆心的位置为 $(x-r,h-r)$，则点 $(a,b)$ 在圆内或圆上必须满足：</p>
<script type="math/tex; mode=display">
r^2\geq (x-r-a)^2 +(h-r-b)^2\\</script><p>记 $a_0=x-a,a_1=h-b$。</p>
<script type="math/tex; mode=display">
r^2\geq (a_0-r)^2+(b_0-r)^2\\
r^2\geq r^2-2a_0r+a_0^2+r^2-2b_0r+b_0^2\\
r^2-(2a_0+2b_0)r+a_0^2+b_0^2\leq 0\\</script><p>解一元二次方程可得到 $r_1,r_2$（$r_1\le r_2$）。则当 $r_1\leq r\leq r_2$ 时，点在圆内或圆上。由于只要求点在半圆内或半圆上，因此当 $b&lt;h-r_1$ 时不取 $r_1$ 的下界。</p>
<p>然后转移的时候维护当前 $r$ 的可选范围即可。</p>
<p>时间复杂度 $O(n^2)$。</p>
<h2 id="Code：-4"><a href="#Code：-4" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e4+6;
typedef long long LL;
int n,h,alpha,beta,X[N],Y[N];
LL d[N];
void solve(int a,int b,LL c,double&amp;x1,double&amp;x2){
    LL dlt=(LL)b*b-4*a*c;
    if(dlt&lt;0){x1=1e11,x2=-1e11;}
    double cd=sqrt(dlt);
    x1=(-b+cd)/(2*a),x2=(-b-cd)/(2*a);
    if(x1&gt;x2)swap(x1,x2);
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n&gt;&gt;h&gt;&gt;alpha&gt;&gt;beta;
    for(int i=1;i&lt;=n;++i)
    cin&gt;&gt;X[i]&gt;&gt;Y[i];
    memset(d,0x3f,sizeof d);
    d[1]=(LL)alpha*(h-Y[1]);
    for(int i=2;i&lt;=n;++i){
        double l=0,r=1e12;
        for(int j=i-1;j;--j){
            int d=X[i]-X[j];
            if(Y[i]*2+d&gt;2*h)break;
            int a1=X[i]-X[j],b1=h-Y[j];
            double x1,x2;
            solve(1,-2*(a1+b1),(LL)a1*a1+(LL)b1*b1,x1,x2);
            if(x1-1e-5&gt;x2)break;
            if(h-x1&lt;=Y[j])l=max(l,x1);
            r=min(r,x2);
            if(l-1e-5&gt;r)break;
            if(l*2-1e-5&lt;=d&amp;&amp;d&lt;=r*2+1e-5)
            ::d[i]=min(::d[i],::d[j]+(LL)alpha*(h-Y[i])+(LL)beta*d*d);
        }
    }
    if(d[n]&gt;1e17)cout&lt;&lt;&quot;impossible\n&quot;;
    else cout&lt;&lt;d[n]&lt;&lt;&#39;\n&#39;;
    return 0;
}
</code></pre>
<hr>
<h1 id="FG"><a href="#FG" class="headerlink" title="FG"></a><div id="FG">FG</div></h1><h2 id="题目大意：-5"><a href="#题目大意：-5" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一棵 $n+1$ 个结点的有根树，每条边上有字母。一个结点代表的字符串是这个结点<strong>到</strong>根的有向路径上经过的边权上的字母依次排列。</p>
<p>有 $k$ 个询问，每个询问给出字符串 $S$，问 $S$ 作为树上多少个结点代表的串的前缀。</p>
<p>$1\leq n,k,\sum |S|\leq 10^5$。</p>
<h2 id="题解：-5"><a href="#题解：-5" class="headerlink" title="题解："></a>题解：</h2><p>考虑把所有串都反过来，那么这棵给定的树就是一棵比较正常的字典树。然后，把询问串倒过来后，相当于询问 $S$ 作为一个串的后缀的出现次数。</p>
<p>对所有询问串建 AC 自动机，然后在 Trie 和 AC 自动机上同时 dfs，将 dfs 到的 AC 自动机上的结点的点权 $+1$。</p>
<p>一个结点代表的串作为后缀的出现次数，就是它在 fail 树上的子树的点权和。最后再 dfs 一遍求子树点权和即可。</p>
<p>时间复杂度 $O(n+k+26\sum |S|)$。</p>
<h2 id="Code：-5"><a href="#Code：-5" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e6+9;
int n,m,fa[N],head[N],aid[N],tot[N];
struct edge{
    int to,nxt;char c;
}e[N];
queue&lt;int&gt;q;
int ch[N][26],fail[N],nod=0;
vector&lt;int&gt;G[N];
void insert(char*s,int id){
    int nw=0;
    for(int i=0;s[i];++i){
        int c=s[i]-&#39;A&#39;;
        if(!ch[nw][c])ch[nw][c]=++nod;
        nw=ch[nw][c];
    }
    aid[id]=nw;
}
void build(){
    for(int i=0;i&lt;26;++i)if(ch[0][i])q.push(ch[0][i]);
    while(!q.empty()){
        int u=q.front();q.pop();
        for(int c=0;c&lt;26;++c)if(ch[u][c]){
            fail[ch[u][c]]=ch[fail[u]][c];
            q.push(ch[u][c]);
        }else ch[u][c]=ch[fail[u]][c];
    }
}
void dfs(int now,int nw){
    int _=nw;
    ++tot[_];
    for(int i=head[now];i;i=e[i].nxt){
        int c=e[i].c-&#39;A&#39;;
        nw=ch[_][c];
        dfs(e[i].to,nw);
    }
}
void DFS(int u){for(int i:G[u])DFS(i),tot[u]+=tot[i];}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=1;i&lt;=n;++i){
        char s[8];
        cin&gt;&gt;s&gt;&gt;fa[i];
        e[i]=(edge){i,head[fa[i]],*s},head[fa[i]]=i;
    }
    for(int i=1;i&lt;=m;++i){
        static char s[N];
        cin&gt;&gt;s;
        reverse(s,s+strlen(s));
        insert(s,i);
    }
    build();
    dfs(0,0);
    for(int i=1;i&lt;=nod;++i)G[fail[i]].push_back(i);
    DFS(0);
    for(int i=1;i&lt;=m;++i)cout&lt;&lt;tot[aid[i]]&lt;&lt;&#39;\n&#39;;
    return 0;
}
</code></pre>
<hr>
<h1 id="LL"><a href="#LL" class="headerlink" title="LL"></a><div id="LL">LL</div></h1><h2 id="题目大意：-6"><a href="#题目大意：-6" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定二维平面 $n$ 个正方形，保证 $4$ 个顶点以及中点都在整点上。</p>
<p>正方形的边保证要么与坐标轴平行，要么与坐标轴夹角为 $45^\circ$。</p>
<p>求 $n$ 个正方形覆盖的部分的面积大小。</p>
<p>$1\leq n\leq 10^5$，$|x|,|y|,|d|\leq 1000$。</p>
<h2 id="题解：-6"><a href="#题解：-6" class="headerlink" title="题解："></a>题解：</h2><p>注意到坐标范围非常地小，因此我们可以直接差分前缀和。</p>
<p>将两类正方形分开处理比较方便。</p>
<p>对于 A 类（与坐标轴平行的），我们令 $A_{i,j}$ 表示左上角为 $(i,j)$ 的小正方形被覆盖的次数。这就是一个基本的二维差分/前缀和。</p>
<p>对于 B 类（不与坐标轴平行的），也可以类似处理。令 $B_{i,j}$ 表示 $(i,j),(i+1,j-1),(i+1,j+1),(i+2,j)$ 为顶点的正方形被覆盖的次数。这个也可以差分/前缀和处理：$B_{i,j}=B_{i,j}+B_{i-1,j-1}+B_{i-1,j+1}-B_{i-2,j}$。</p>
<p>在坐标范围平方的时间内处理即可。</p>
<h2 id="Code：-6"><a href="#Code：-6" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n;
struct array{
    int a[4005][4005];
    inline int*operator[](const int&amp;x){return a[x+2001]+2001;}
}A,B;
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n;
    while(n--){
        char tp[8];
        int x,y,d;
        cin&gt;&gt;tp&gt;&gt;x&gt;&gt;y&gt;&gt;d;
        d/=2;
        if(*tp&lt;&#39;B&#39;){
            ++A[x-d][y-d],--A[x-d][y+d],--A[x+d][y-d],++A[x+d][y+d];
        }else{
            ++B[x-d][y],--B[x][y-d],--B[x][y+d],++B[x+d][y];
        }
    }
    for(int i=-1500;i&lt;=1500;++i)
    for(int j=-1500;j&lt;=1500;++j){
        A[i][j]+=A[i-1][j]+A[i][j-1]-A[i-1][j-1];
        B[i][j]+=B[i-1][j-1]+B[i-1][j+1]-B[i-2][j];
    }
    int ans=0;
    for(int i=-1500;i&lt;=1500;++i)
    for(int j=-1500;j&lt;=1500;++j)
    if(A[i][j])ans+=4;else{
        if(B[i-1][j+1]||B[i][j+1])++ans;
        if(B[i][j+1]||B[i][j])++ans;
        if(B[i][j]||B[i-1][j])++ans;
        if(B[i-1][j]||B[i-1][j+1])++ans;
    }
    printf(&quot;%.2f\n&quot;,ans/4.);
    return 0;
}
</code></pre>
<hr>
<h1 id="QE"><a href="#QE" class="headerlink" title="QE"></a><div id="QE">QE</div></h1><h2 id="题目大意：-7"><a href="#题目大意：-7" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定 $n$ 个正整数 $a_1,a_2,\dots,a_n$，你每次可以对一个数进行操作，使它乘上任意一个正整数。</p>
<p>对 $0\sim n$ 的每个整数 $k$，求出恰好进行 $k$ 次操作时，$n$ 个整数中不同的整数个数最少是多少。</p>
<p>$1\leq n\leq 3\times 10^5$，$1\leq a_i\leq 10^6$。</p>
<h2 id="题解：-7"><a href="#题解：-7" class="headerlink" title="题解："></a>题解：</h2><p>考虑如何让不同的整数个数减少。</p>
<p>有两种方式：</p>
<ol>
<li>对于一个值的数，若原来的整数中存在它的 $2$ 倍及以上的倍数，则变成它的倍数，使整数个数减少 $1$。</li>
<li>找到 $a_1,a_2,\ldots,a_n$ 的任意一个公倍数，对于一些数，将它们都变成这个公倍数。</li>
</ol>
<p>最开始做的时候我以为最优的做法是两种方法结合，即执行 1 操作一部分后再执行 2 操作。实际上，两种方法应该分开计算。</p>
<p>1 执行一段后再执行 2 的做法，我们可以把 1 执行的那一段也变成 2 的段，这样答案并不会变劣。</p>
<p>然后显然出现次数少的数优先执行操作。因此对出现次数排序计算即可。</p>
<h2 id="Code：-7"><a href="#Code：-7" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e6+7;
int n,a[N],tot[N];
vector&lt;int&gt;A,B;
bool vis[N];
int ans[N];
int main(){
    freopen(&quot;equal.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;equal.out&quot;,&quot;w&quot;,stdout);
    memset(ans,0x3f,sizeof ans);*ans=0;
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i)cin&gt;&gt;a[i],++tot[a[i]],vis[a[i]]=1;
    A.push_back(0),B.push_back(0);
    for(int i=1;i&lt;=1000000;++i)if(tot[i]){
        A.push_back(tot[i]),++*ans;
        for(int j=i+i;j&lt;=1000000;j+=i)if(tot[j]){B.push_back(tot[i]);break;}
    }
    sort(A.begin(),A.end());
    sort(B.begin(),B.end());
    for(int i=1;i&lt;(int)A.size();++i)A[i]+=A[i-1];
    for(int i=1;i&lt;(int)B.size();++i)B[i]+=B[i-1];
    for(int i=1,it=0;i&lt;=n;++i){
        while(it+1&lt;(int)A.size()&amp;&amp;A[it+1]&lt;=i)++it;
        ans[i]=min(ans[i],*ans-it+1);
    }
    for(int i=1,it=0;i&lt;=n;++i){
        while(it+1&lt;(int)B.size()&amp;&amp;B[it+1]&lt;=i)++it;
        ans[i]=min(ans[i],*ans-it);
    }
    for(int i=1;i&lt;=n;++i)ans[i]=min(ans[i],ans[i-1]);
    for(int i=0;i&lt;=n;++i)cout&lt;&lt;ans[i]&lt;&lt;&#39; &#39;;
    return 0;
}
</code></pre>
<hr>
<h1 id="RJ"><a href="#RJ" class="headerlink" title="RJ"></a><div id="RJ">RJ</div></h1><h2 id="题目大意：-8"><a href="#题目大意：-8" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有一种语言，数的值域在 $0..255$ 之间。支持 <code>+ - * / min max</code> 操作（除法为四舍五入，其他运算在模 $256$ 意义下进行）。</p>
<p>操作数只有 <code>?</code>，每个 <code>?</code> 都是一个独立的 $0..255$ 之间均匀随机的数。</p>
<p>支持宏定义 <code>&lt;mac&gt; = &lt;exp&gt;</code>，代码中所有 <code>&lt;mac&gt;</code> 都会被 <code>(&lt;exp&gt;)</code> 替代。</p>
<p>除了宏定义以外，你只能写一个该语言的表达式，它的运算结果将被输出。</p>
<p>给定 $c$，你需要给出一段除去空白字符后长度不超过 $256$ 的该语言的代码，使得代码的输出为 $c$ 的概率不小于 $\frac 1 2$。</p>
<h2 id="题解：-8"><a href="#题解：-8" class="headerlink" title="题解："></a>题解：</h2><p>$c=0$ 的情况样例已经给出，直接输出即可。</p>
<p>$c=1\sim 255$ 的情况不难想到按位处理。</p>
<p>我们将 $2^0,2^1,2^2,\ldots,2^7$ 用宏表示出来，然后就可以直接组成所有的 $c$。</p>
<p>那么我们需要准确地搞出这 $8$ 个数来。</p>
<p>我们考虑造一个 $1$。我们把很多的 <code>?</code> 取最大值，让它有极高概率为 $255$，然后两个相除就是 $1$ 了。</p>
<p>剩下的 $2^i$ 可以由两个 $2^{i-1}$ 相加得到。</p>
<p>为了让弄出来的数尽可能多使得最大值为 $255$ 的概率接近 $1$，用多层宏定义的方式来做即可。</p>
<h2 id="Code：-8"><a href="#Code：-8" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int res;
const char s[]={&#39;f&#39;,&#39;g&#39;,&#39;h&#39;,&#39;i&#39;,&#39;j&#39;,&#39;k&#39;,&#39;l&#39;,&#39;m&#39;};
int main(){
    freopen(&quot;java2016.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;java2016.out&quot;,&quot;w&quot;,stdout);
    scanf(&quot;%d&quot;,&amp;res);
    if(res==0)return puts(&quot;? / ? / ? / ?&quot;),0;
    puts(&quot;a = ? max ? max ? max ? max ? max ? max ? max ?&quot;);
    puts(&quot;b = a max a max a max a max a max a max a max a&quot;);
    puts(&quot;c = b max b max b max b max b max b max b max b&quot;);
    puts(&quot;d = c max c max c max c max c max c max c max c&quot;);
    puts(&quot;e = d / d&quot;);
    puts(&quot;f = e max e max e max e max e max e max e max e&quot;);
    puts(&quot;g = f + f&quot;);
    puts(&quot;h = g + g&quot;);
    puts(&quot;i = h + h&quot;);
    puts(&quot;j = i + i&quot;);
    puts(&quot;k = j + j&quot;);
    puts(&quot;l = k + k&quot;);
    puts(&quot;m = l + l&quot;);
    string ans=&quot;&quot;;
    for(int i=0;i&lt;8;++i)if(res&gt;&gt;i&amp;1)ans.push_back(s[i]),ans+=&quot; + &quot;;
    ans.pop_back();
    ans.pop_back();
    ans.pop_back();
    puts(ans.c_str());
    return 0;
}
</code></pre>
<hr>
<h1 id="RG"><a href="#RG" class="headerlink" title="RG"></a><div id="RG">RG</div></h1><h2 id="题目大意：-9"><a href="#题目大意：-9" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一棵大小为 $n$ 的有根树。有 $q$ 个操作：</p>
<ol>
<li>给定 $v$，将 $v$ 号结点上面加上一个强盗。保证之前没有。</li>
<li>给定 $v$，将 $v$ 号结点上面减去一个强盗。保证之前有。</li>
</ol>
<p>你需要断掉最少的边，使所有强盗都不与根连通。在此基础上，你需要使<strong>没有强盗</strong>且不与根连通的<strong>叶结点</strong>最少。</p>
<p>每次操作完后，输出最少需要断掉的边，和在此基础上<strong>没有强盗</strong>且不与根连通的<strong>叶结点</strong>的最少个数。</p>
<p>$1\leq n,q\leq 10^5$。</p>
<h2 id="题解：-9"><a href="#题解：-9" class="headerlink" title="题解："></a>题解：</h2><p>数据范围小，可以使用树剖线段树。</p>
<p>考虑根的每个儿子的子树。显然每个儿子的子树里最多割掉一条边（割掉儿子到根的边是其中一种方案）。</p>
<p>割掉一条边，相当于割掉一棵子树，这棵子树必须得包含所有的强盗。</p>
<p>我们对每个强盗，将他所在结点到根路径上的点权都加一，那么如果有 $k$ 个强盗，必须割掉根的权值为 $k$ 的子树。由于权值不可能超过 $k$，所以就是点权的最大值。</p>
<p>不难发现权值恰好为 $k$ 的点一定是一条到根的路径。为了使包含的叶子尽可能少，我们要选最深的那个结点。所以第二关键字取结点深度或 dfs 序即可。</p>
<p>然后直接树剖线段树实现链加、子树最大值即可。</p>
<p>时间复杂度 $O(n+q\log^2 n)$。</p>
<h2 id="Code：-9"><a href="#Code：-9" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e5+6;
int n,m,fa[N],sz[N],son[N],dfn[N],idx,dep[N],top[N],ts[N],idfn[N],head[N],leaf[N];
int _[N],es,_totqd,_sumsz;
pair&lt;int,int&gt;d[N&lt;&lt;2];
int tag[N&lt;&lt;2];
struct edge{
    int to,nxt;
}e[N];
void dfs(int now,int&amp;rt){
    ts[now]=rt;
    sz[now]=1,son[now]=0;
    for(int i=head[now];i;i=e[i].nxt){
        dep[e[i].to]=dep[now]+1;
        dfs(e[i].to,rt);
        sz[now]+=sz[e[i].to];
        leaf[now]+=leaf[e[i].to];
        if(!son[now]||sz[son[now]]&lt;sz[e[i].to])
        son[now]=e[i].to;
    }
}
void dfs2(int now){
    idfn[dfn[now]=++idx]=now;
    if(son[now])top[son[now]]=top[now],dfs2(son[now]);
    for(int i=head[now];i;i=e[i].nxt)if(e[i].to!=son[now])
    dfs2(top[e[i].to]=e[i].to);
}
inline void pushdown(int o){
    if(int&amp;x=tag[o]){
        d[o&lt;&lt;1].first+=x,d[o&lt;&lt;1|1].first+=x;
        tag[o&lt;&lt;1]+=x,tag[o&lt;&lt;1|1]+=x;
        x=0;
    }
}
void build(int l,int r,int o){
    if(l==r)d[o].second=l;else{
        const int mid=(l+r)/2;
        build(l,mid,o&lt;&lt;1),build(mid+1,r,o&lt;&lt;1|1);
        d[o]=max(d[o&lt;&lt;1],d[o&lt;&lt;1|1]);
    }
}
void modify(int l,int r,int o,const int&amp;L,const int&amp;R,const int&amp;v){
    if(L&lt;=l&amp;&amp;r&lt;=R)d[o].first+=v,tag[o]+=v;
    else{
        pushdown(o);
        const int mid=(l+r)/2;
        if(L&lt;=mid)modify(l,mid,o&lt;&lt;1,L,R,v);
        if(mid&lt;R)modify(mid+1,r,o&lt;&lt;1|1,L,R,v);
        d[o]=max(d[o&lt;&lt;1],d[o&lt;&lt;1|1]);
    }
}
pair&lt;int,int&gt;query(int l,int r,int o,const int&amp;L,const int&amp;R){
    if(L&lt;=l&amp;&amp;r&lt;=R)return d[o];
    pushdown(o);
    const int mid=(l+r)/2;
    if(L&lt;=mid&amp;&amp;mid&lt;R)return max(query(l,mid,o&lt;&lt;1,L,R),query(mid+1,r,o&lt;&lt;1|1,L,R));
    if(L&lt;=mid)return query(l,mid,o&lt;&lt;1,L,R);
    return query(mid+1,r,o&lt;&lt;1|1,L,R);
}
inline void add(int v,int x){
    while(top[v]!=1)modify(1,n,1,dfn[top[v]],dfn[v],x),v=fa[top[v]];
    modify(1,n,1,1,dfn[v],x);
}
int main(){
    freopen(&quot;gangsters.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;gangsters.out&quot;,&quot;w&quot;,stdout);
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m;
    for(int i=2;i&lt;=n;++i){
        cin&gt;&gt;fa[i];
        e[i]=(edge){i,head[fa[i]]},head[fa[i]]=i;
    }
    for(int i=1;i&lt;=n;++i)leaf[i]=!head[i];
    dep[1]=1;
    sz[1]=n;
    for(int i=head[1];i;i=e[i].nxt){
        dep[e[i].to]=2;
        dfs(e[i].to,e[i].to);
        if(!son[1]||sz[son[1]&lt;sz[e[i].to]])son[1]=e[i].to;
        leaf[1]+=leaf[e[i].to];
    }
    dfs2(top[1]=1);
    build(1,n,1);
    while(m--){
        char op[8];int v;
        cin&gt;&gt;op&gt;&gt;v;
        if(*op==&#39;+&#39;){
            int tr=ts[v];
            if(!_[tr])++es;else _sumsz-=leaf[_[tr]];
            add(v,1);
            pair&lt;int,int&gt;x=query(1,n,1,dfn[tr],dfn[tr]+sz[tr]-1);
            _[tr]=idfn[x.second];
            _sumsz+=leaf[_[tr]];
            if(leaf[v]==1)++_totqd;
        }else{
            int tr=ts[v];
            _sumsz-=leaf[_[tr]];
            add(v,-1);
            pair&lt;int,int&gt;x=query(1,n,1,dfn[tr],dfn[tr]+sz[tr]-1);
            _[tr]=idfn[x.second];
            if(x.first==0)_[tr]=0,--es;
            else _sumsz+=leaf[_[tr]];
            if(leaf[v]==1)--_totqd;
        }
        cout&lt;&lt;es&lt;&lt;&#39; &#39;&lt;&lt;_sumsz-_totqd&lt;&lt;&#39;\n&#39;;
    }
    return 0;
}
</code></pre>
<hr>
<h1 id="CK"><a href="#CK" class="headerlink" title="CK"></a><div id="CK">CK</div></h1><h2 id="题目大意：-10"><a href="#题目大意：-10" class="headerlink" title="题目大意："></a>题目大意：</h2><p>定义：</p>
<p>由一对单引号中间有一些不带引号的文字组成的串为一级串。</p>
<p>左右各有 $k$ 个单引号，中间为若干 $k-1$ 级串和不带单引号的文字拼接而成的字符串为 $k$ 级串。</p>
<p>例如 <code>&#39;&#39;All &#39;work&#39; and no &#39;play&#39;&#39;&#39;</code> 是一个 $2$ 级串。</p>
<p>现在文字消失了，只留下一些引号，并且有一些引号中间的空不见了。</p>
<p>给定 $n$ 段引号的个数 $a_1,a_2,\ldots,a_n$，问这段引号原来最大能是几级串。无解输出 <code>no quotation</code>。</p>
<p>$k$ 个引号可以拆成 $a$ 个引号和 $(k-a)$ 个引号，可以继续拆分。但是两段引号不能拼接起来。</p>
<p>$1\leq n,a_i\leq 100$。</p>
<h2 id="题解：-10"><a href="#题解：-10" class="headerlink" title="题解："></a>题解：</h2><p>首先，<strong>引号个数之和必定是偶数</strong>，否则显然无解。</p>
<p>其次，不难发现，$k$ 级引号的最左边必然有 $k,k-1,k-2,\ldots,1$ 个引号，最右边必然有 $1,2,3,\ldots,k$ 个引号。</p>
<p>这样中间还有偶数个引号。</p>
<p>那么一个非常简单的构造方案就是：中间这些全都是 $1$ 级串。由于中间有偶数个引号，因此一定可行。</p>
<p>所以只需要枚举答案，判断前缀、后缀是否满足条件即可。</p>
<p>特判答案为 $1$ 的情况。</p>
<h2 id="Code：-10"><a href="#Code：-10" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
int n,a[105],sum,b[105];
bool check(int*A,int x){
    int it=1,p=A[1];
    for(int i=x;i;--i){
        if(p&lt;i)return 0;
        if(p&gt;i)p-=i;else p=A[++it];
    }
    return 1;
}
int main(){
    scanf(&quot;%d&quot;,&amp;n);
    for(int i=1;i&lt;=n;++i)scanf(&quot;%d&quot;,a+i),sum+=a[i];
    memcpy(b,a,sizeof a);
    reverse(b+1,b+n+1);
    if(sum&amp;1)return puts(&quot;no quotation&quot;),0;
    if(sum==2)return puts(&quot;1&quot;),0;
    int ans=-1;
    for(int i=2;;++i){
        int x=(i+1)*i;
        if(x&gt;sum)break;
        if(check(a,i)&amp;&amp;check(b,i))ans=i;
    }
    if(ans==-1)puts(&quot;no quotation&quot;);else printf(&quot;%d\n&quot;,ans);
    return 0;
}
</code></pre>
<hr>
<h1 id="KH"><a href="#KH" class="headerlink" title="KH"></a><div id="KH">KH</div></h1><h2 id="题目大意：-11"><a href="#题目大意：-11" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个长度为 $n$ 的序列 $a$，问有多少子区间的 and 和与 xor 和相等。</p>
<p>$1\leq n\leq10^5$，$0\leq a_i\lt 2^{31}$。</p>
<h2 id="题解：-11"><a href="#题解：-11" class="headerlink" title="题解："></a>题解：</h2><p>枚举左端点 $l$。对每个二进制位考虑。我们找到这个二进制位在右边第一次为 $0$ 的位置 $k$，则对于 $r\in[l,k-1]$，$[l,r]$ 的 and 和的这一位一定为 $1$。而对于 $r\in[k,n]$，$[l,r]$ 的 and 和的这一位一定为 $0$。</p>
<p>因此对于一个左端点，区间 and 和的不同取值只有 $\log a$ 种，且每种。我们只需要从大到下枚举左端点，同时维护每个二进制位的 $0$ 的最左边出现位置即可。</p>
<p>对于 xor 和，我们记录前缀 xor 和，然后相当于在 $\log a$ 个区间里查询某个数的出现次数。直接二分即可。</p>
<p>时间复杂度 $O(n\log n\log a)$。</p>
<h2 id="Code：-11"><a href="#Code：-11" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N=1e5+5;
int n,a[N],b[N],W[32];
map&lt;int,vector&lt;int&gt; &gt;mp;
pair&lt;int,int&gt;pr[32];
LL ans;
int calc(int w,int l,int r){
    if(l&gt;r||!mp.count(w))return 0;
    vector&lt;int&gt;&amp;vc=mp[w];
    return upper_bound(vc.begin(),vc.end(),r)-lower_bound(vc.begin(),vc.end(),l);
}
int main(){
    freopen(&quot;hack.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;hack.out&quot;,&quot;w&quot;,stdout);
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i)cin&gt;&gt;a[i];
    for(int i=n;i;--i)b[i]=b[i+1]^a[i];
    for(int i=1;i&lt;=n;++i){
        mp[b[i]].push_back(i);
        for(int j=0;j&lt;31;++j)if(!(a[i]&gt;&gt;j&amp;1))W[j]=i;
        for(int j=0;j&lt;31;++j)pr[j]=make_pair(W[j],j);
        sort(pr,pr+31);
        int nt=2147483647,nr=i;
        for(int j=30;~j;--j){
            ans+=calc(nt^b[i+1],pr[j].first+1,nr);
            nr=pr[j].first;
            if(!nr)break;
            nt^=1&lt;&lt;pr[j].second;
        }
        if(nr)ans+=calc(nt^b[i+1],1,nr);
    }
    cout&lt;&lt;ans&lt;&lt;&#39;\n&#39;;
    return 0;
}
</code></pre>
<hr>
<h1 id="IK"><a href="#IK" class="headerlink" title="IK"></a><div id="IK">IK</div></h1><h2 id="题目大意：-12"><a href="#题目大意：-12" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个 $n$ 个点 $m$ 条边的有向图。</p>
<p>要求找到一条 $1$ 出发回到 $1$ 的经过每个其他点各 $1$ 次，经过 $n$ 条边的路径。</p>
<p>$2\leq n\leq 10^5$，$0\leq m\leq n+20$。</p>
<h2 id="题解：-12"><a href="#题解：-12" class="headerlink" title="题解："></a>题解：</h2><p>若 $m&lt;n$ 则显然无解。</p>
<p>令 $k=m-n$。</p>
<p>考虑到只有最多 $20$ 条非环边，相关的有 $40$ 个不同的点。那么其他的点的入度和出度必然都为 $1$。</p>
<p>我们把这些点和相关的边缩起来，则最多剩下 $2k$ 个点和 $2k$ 条边。</p>
<p>爆搜即可。分析一下复杂度应该是 $O(2^kk)$。实际运行时效率很高。</p>
<h2 id="Code：-12"><a href="#Code：-12" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
const int N=100022;
using namespace std;
const char*tok=&quot;There is no route, Karl!&quot;;
vector&lt;int&gt;G[N],_G[N];
vector&lt;int&gt;e_id[N];
int n,m,id,dg1[N],dg2[N],rot;
int city[N],_id[N];
bool vis[N],Key[N];
void output(){
    for(int i=0;i&lt;n;++i)
        cout&lt;&lt;city[i]&lt;&lt;&#39; &#39;;
    cout&lt;&lt;1&lt;&lt;&#39;\n&#39;;
    exit(0);
}
void dfs(int now,int num){
    if(vis[now]){
        if(num==n&amp;&amp;now==1)output();
        return;
    }
    city[num]=now;
    vis[now]=1;
    for(int i:G[now])dfs(i,num+1);
}
void init(){
    for(int i=1;i&lt;=n;++i)if(dg1[i]&gt;1||dg2[i]&gt;1)Key[i]=1;
    for(int x=1;x&lt;=n;++x)if(Key[x]){
        for(int to:G[x]){
            ++id;
            int nw=to;
            e_id[id].push_back(nw);
            while(!Key[nw]){
                nw=G[nw][0];
                e_id[id].push_back(nw);
            }
            if(nw!=x)_G[x].push_back(id);
        }
    }
}
void _(int t){
    static vector&lt;int&gt;ans;
    for(int i=0;i&lt;t;++i)
        for(int to:e_id[_id[i]])ans.push_back(to);
    int pos=-1;
    for(int i=0;i&lt;(int)ans.size()&amp;&amp;pos==-1;++i)
        if(ans[i]==1)pos=i;
    if(pos==-1)exit(1);
    for(int i=pos;i&lt;(int)ans.size();++i)cout&lt;&lt;ans[i]&lt;&lt;&#39; &#39;;
    for(int i=0;i&lt;pos;++i)cout&lt;&lt;ans[i]&lt;&lt;&#39; &#39;;
    cout&lt;&lt;&quot;1\n&quot;;
    exit(0);
}
void DFS(int now,int top,int tot){
    if(vis[now]){
        if(tot==n&amp;&amp;now==rot)_(top);
        return;
    }
    vis[now]=1;
    for(int num:_G[now]){
        int to=e_id[num].back();
        _id[top]=num;
        DFS(to,top+1,tot+(int)e_id[num].size());
    }
    vis[now]=0;
}
int main(){
    freopen(&quot;king.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;king.out&quot;,&quot;w&quot;,stdout);
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n&gt;&gt;m;
    if(n&gt;m)return cout&lt;&lt;tok&lt;&lt;&#39;\n&#39;,0;
    while(m--){
        int u,v;
        cin&gt;&gt;u&gt;&gt;v;
        if(u==v)continue;
        G[u].push_back(v);
        ++dg1[u],++dg2[v];
    }
    for(int i=1;i&lt;=n;++i)if(!dg1[i]||!dg2[i]){
        cout&lt;&lt;tok&lt;&lt;&#39;\n&#39;;
        return 0;
    }
    dfs(1,0);
    init();
    memset(vis,0,sizeof vis);
    for(int i=1;i&lt;=n;++i)if(Key[i]){rot=i,DFS(i,0,0);break;}
    cout&lt;&lt;tok&lt;&lt;&#39;\n&#39;;
    return 0;
}
</code></pre>
<hr>
<h1 id="RI"><a href="#RI" class="headerlink" title="RI"></a><div id="RI">RI</div></h1><h2 id="题目大意：-13"><a href="#题目大意：-13" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定 $n$ 个整点围成的凸多边形。求有多少条对角线将凸多边形分成两块面积均为整数的部分。</p>
<p>$3\leq n\le 2\times 10^5$。</p>
<h2 id="题解：-13"><a href="#题解：-13" class="headerlink" title="题解："></a>题解：</h2><p>一步简单的转化：求有多少条对角线将凸多边形分成两块面积的两倍均为偶数的部分。</p>
<p>如果凸多边形的面积的两倍是奇数，则显然无解。所以我们只需要考虑被分割的其中一块的面积的两倍的奇偶性。</p>
<p>我们先固定一个端点 $A$，并求出所有对角线 $A,B$ 分割出的面积的两倍的奇偶性情况。</p>
<p>然后按顺序枚举 $A$，考虑 $A$ 变成 $C$（存在边 $A,C$）时，其他点作为另一个端点时的奇偶性情况。</p>
<p>当 $(A,B)$ 变为 $(C,B)$ 时，其面积的两倍的变化量为 $\vec{BA}\times\vec{BC}$。</p>
<p>将其展开。</p>
<script type="math/tex; mode=display">
\begin{align}
\vec{BA}\times\vec{BC}&=(A.x-B.x)(C.y-B.y)-(A.y-B.y)(C.x-B.x)\\
&=A.x\cdot C.y-A.x\cdot B.y-B.x\cdot C.y+B.x\cdot B.y-A.y\cdot C.x+A.y\cdot B.x+B.y\cdot C.x-B.y\cdot B.x\\
&=A.x\cdot C.y-A.y\cdot C.x+B.x\cdot(A.y-C.y)+B.y\cdot(A.x-A.x)\\
&=A\times C+B.x\cdot(A.y-C.y)+B.y\cdot(A.x-A.x)\\
\end{align}</script><p>考虑它的奇偶性。</p>
<p>发现对于 $A,C$，我们只需要关心每个 $B$ 的两个坐标的奇偶性，就可以知道它们的面积的两倍的奇偶性是否发生了改变。</p>
<p>而 $B$ 两个坐标的奇偶性的不同情况只有 $4$ 种，对其分别记录总个数、当前个数。那么奇偶性翻转时只需要将当前个数改成总个数减去当前个数即可。</p>
<p>时间复杂度 $O(n)$。</p>
<h2 id="Code：-13"><a href="#Code：-13" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N=2e5+50;
struct point{
    int x,y;
    inline point operator-(const point&amp;rhs)const{return(point){x-rhs.x,y-rhs.y};}
}a[N];
inline LL cross(const point&amp;a,const point&amp;b){
    return(LL)a.x*b.y-(LL)a.y*b.x;
}
int n,zt[N],in[4],ct[4];
LL ans;
inline void flip(int x){
    in[x]=ct[x]-in[x];
}
int main(){
    freopen(&quot;integral.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;integral.out&quot;,&quot;w&quot;,stdout);
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i)cin&gt;&gt;a[i].x&gt;&gt;a[i].y;
    int cur=0;
    for(int i=1;i&lt;=n;++i){
        int s=(a[i].x&amp;1)&lt;&lt;1|(a[i].y&amp;1);
        zt[i]=s;
        ++ct[s];
    }
    ++in[zt[1]];
    for(int i=2;i&lt;=n;++i){
        LL res=cross(a[i]-a[1],a[i-1]-a[1]);
        cur^=res&amp;1;
        if(!cur)++in[zt[i]];
    }
    if(cur){
        cout&lt;&lt;0&lt;&lt;&#39;\n&#39;;
        return 0;
    }
    ans+=in[0]+in[1]+in[2]+in[3]-3;
    for(int i=2;i&lt;=n;++i){
        if(cross(a[i],a[i-1])&amp;1)flip(0),flip(1),flip(2),flip(3);
        if((a[i].x+a[i-1].x)&amp;1)flip(1),flip(3);
        if((a[i].y+a[i-1].y)&amp;1)flip(2),flip(3);
        ans+=in[0]+in[1]+in[2]+in[3]-3;
    }
    cout&lt;&lt;ans/2&lt;&lt;&#39;\n&#39;;
    return 0;
}
</code></pre>
<hr>
<h1 id="GJ"><a href="#GJ" class="headerlink" title="GJ"></a><div id="GJ">GJ</div></h1><h2 id="题目大意：-14"><a href="#题目大意：-14" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定 $n$ 个点 $m$ 条边的带权无向图（权值为正）。你要从 $1$ 出发到 $n$，对于每一种走法，它的代价是经过的所有边中最大的 $k$ 条边的边权和（不足 $k$ 条则为全部）。求最小代价。</p>
<p>$n,m\leq 3000$，$1\leq k\lt n$。</p>
<h2 id="题解：-14"><a href="#题解：-14" class="headerlink" title="题解："></a>题解：</h2><p>对于不到 $k$ 条的我们可以直接跑最短路。</p>
<p>我们考虑枚举边权 $v$，并钦定它是第 $k$ 大的边权。对于原图上的每条边 $(u,v,w)$，我们将它的权值变为 $\max(0,w-v)$。然后跑最短路，并尝试用 $(\mathrm{dist}(1,n)+k\cdot v)$ 更新答案。</p>
<p>正确性说明：</p>
<p>除去不到 $k$ 条边的情况，最优答案一定只计算恰好 $k$ 条边的代价。</p>
<p>对于一个 $v$，若它的最短路中<strong>实际应该</strong>计算代价的边超过 $k$ 条，则会多统计一些边的权值。因此增大 $v$ 一定有更优的答案。</p>
<p>剩下的情况就是恰好 $k$ 条的情况。由于我们取的是最小值，因此就是最优解。</p>
<p>时间复杂度 $O(m^2\log n)$。</p>
<h2 id="Code：-14"><a href="#Code：-14" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N=3005;
struct edge{
    int to,nxt,w;
}e[N*2];
struct data{
    int u;LL d;
    inline bool operator&lt;(const data&amp;rhs)const{return d&gt;rhs.d;}
};
std::priority_queue&lt;data&gt;q;
int n,m,k,head[N],S,T;
LL ans=0x3fffffffffffffff;
LL dis[N];
bool vis[N];
void spfa(int wt){
    memset(vis,0,sizeof vis);
    memset(dis,0x3f,sizeof dis);
    dis[S]=0;
    for(q.push((data){S,dis[S]});!q.empty();){
        int u=q.top().u;q.pop();
        if(vis[u])continue;
        vis[u]=1;
        for(int i=head[u];i;i=e[i].nxt){
            LL dt=dis[u]+max(0,e[i].w-wt);
            if(dt&lt;dis[e[i].to])dis[e[i].to]=dt,q.push((data){e[i].to,dt});
        }
    }
    ans=min(ans,dis[T]+k*(LL)wt);
}
int main(){
    scanf(&quot;%d%d%d&quot;,&amp;n,&amp;m,&amp;k);
    int cnt=0;
    S=1,T=n;
    for(int i=1;i&lt;=m;++i){
        int u,v,w;
        scanf(&quot;%d%d%d&quot;,&amp;u,&amp;v,&amp;w);
        e[++cnt]=(edge){v,head[u],w},head[u]=cnt;
        e[++cnt]=(edge){u,head[v],w},head[v]=cnt;
    }
    spfa(0);
    for(int i=1;i&lt;=2*m;i+=2)spfa(e[i].w);
    printf(&quot;%lld\n&quot;,ans);
    return 0;
}
</code></pre>
<hr>
<h1 id="TF"><a href="#TF" class="headerlink" title="TF"></a><div id="TF">TF</div></h1><h2 id="题目大意：-15"><a href="#题目大意：-15" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一个长度为 $n$ 的序列 $a_1,a_2,a_3,\ldots,a_n$，求至少将其分成多少个连续段，满足这些连续段通过重排后依次拼接，能够使 $a_i$ 单调不下降。</p>
<p>$1\leq n\leq 10^5$。</p>
<h2 id="题解：-15"><a href="#题解：-15" class="headerlink" title="题解："></a>题解：</h2><p>对 $a_i$ 进行离散化，设序列为 $a_i’$，得到序列中不同的数有 $m$ 种。那么重排后 $a_i’$ 的顺序一定是 $1$ 到 $m$。</p>
<p>我们考虑将连续的相同元素划到一个段中，它们在答案中一定相邻，否则必然可以通过将它们放到相邻位置使答案变优。</p>
<p>假设有 $k$ 个这样的连续段。我们需要让连续段个数尽可能小，所以相当于最大化最终序列中位置相邻的连续段个数。</p>
<p>枚举 $a_i’$ 的取值。不难发现，这个取值的所有连续段中，只有放在开头的和结尾的两个段才可能和其他段拼成一个连续段。</p>
<p>不妨令 $f_i$ 表示段 $i$ 作为这个取值的开头时，能在 $k$ 个连续段基础上减少<strong>最多</strong>的连续段个数。令 $g_i$ 表示段 $i$ 作为这个取值的结尾时，能在 $k$ 个连续段基础上减少<strong>最多</strong>的连续段个数。</p>
<p>$f_i$ 有两种转移：一是直接拼在上一种取值的最大的 $g_j$ 后面（$f_i=\max\{g_j\}$）；另一种是拼在它前面那段的后面，并多减少一个（$f_i=g_{i-1}+1$）必须满足段 $i-1$ 的取值恰好比段 $i$ 的取值小 $1$ 才能转移。</p>
<p>若不存在与 $i$ 同取值的其它段，则 $g_i=f_i$。否则若 $i$ 不是 $f$ 中最大的，则 $g_i$ 直接从 $f$ 中的最大值转移过来；反之则从次大值转移过来。</p>
<p>最后分成的最小段数就是 $(k-\max\{g_i\})$。</p>
<p>考虑输出答案。我们对于每个段作为取值的开头，记录最优情况下上一个段的编号；对于每个段作为取值的结尾，记录最优情况下当前取值的开头段的编号。然后倒推可以得到所有取值的开头和结尾段的编号。中间的随便怎么排都行。</p>
<p>然后根据最终序列，不难推出原序列的分段情况。</p>
<p>时间复杂度 $O(n\log n)$（sort） 或 $O(n)$（计数排序）。</p>
<h2 id="Code：-15"><a href="#Code：-15" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1e5+5;
int n,a[N],b[N],mdf[N],m,mx[N],dp[N],pre[N],ans,pid[N],dip[N],qwq[N];
bool vis[N];
vector&lt;int&gt;pos[N];
int main(){
    freopen(&quot;fragmentation.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;fragmentation.out&quot;,&quot;w&quot;,stdout);
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i)cin&gt;&gt;a[i],b[i]=a[i];
    sort(b+1,b+n+1);
    mdf[b[1]]=++m;
    for(int i=2;i&lt;=n;++i)
    if(mdf[b[i]]!=mdf[b[i-1]])mdf[b[i]]=++m;
    for(int i=1;i&lt;=n;++i)a[i]=mdf[a[i]];
    ans=1;
    pos[a[1]].push_back(1);
    vis[1]=1;
    int pr=1;
    for(int i=2;i&lt;=n;++i)if(a[i]!=a[i-1])
    pos[a[i]].push_back(i),pre[i]=pr,pr=i,++ans,vis[i]=1;
    for(int i:pos[1])dp[i]=0;
    mx[1]=0;
    if(pos[1].size()==1u)pid[pos[1][0]]=pos[1][0];else
    for(int i:pos[1]){
        if(i!=pos[1][0])pid[i]=pos[1][0];
        else pid[i]=pos[1][1];
    }
    qwq[1]=pos[1][0];
    if(m==1)
    cout&lt;&lt;1&lt;&lt;&#39;\n&#39;&lt;&lt;n&lt;&lt;&#39;\n&#39;;
    for(int x=2;x&lt;=m;++x){
        int mx1=-1,id1=0,mx2=-1,id2=0;
        for(int i:pos[x]){
            int dlt=mx[x-1];
            dip[i]=qwq[x-1];
            if(a[pre[i]]==x-1&amp;&amp;dp[pre[i]]+1&gt;dlt){
                dlt=dp[pre[i]]+1,dip[i]=pre[i];
            }
            if(dlt&gt;mx1)mx2=mx1,id2=id1,mx1=dlt,id1=i;
            else if(dlt&gt;mx2)mx2=dlt,id2=i;
        }
        if(pos[x].size()==1u)dp[pos[x][0]]=mx1,pid[id1]=id1;else
        for(int i:pos[x])if(i==id1)dp[i]=mx2,pid[i]=id2;else dp[i]=mx1,pid[i]=id1;
        mx[x]=mx1,qwq[x]=id2?id2:id1;
        if(x==m){
            cout&lt;&lt;ans-mx1&lt;&lt;&#39;\n&#39;;
            vector&lt;int&gt;vc;
            for(int i=id2?id2:id1;pid[i];i=dip[pid[i]]){
                int pre=pid[i];
                if(pre==i)vc.push_back(pre);else{
                    vc.push_back(i);
                    for(int j:pos[a[i]])if(j!=i&amp;&amp;j!=pre)
                    vc.push_back(j);
                    vc.push_back(pre);
                }
            }
            vector&lt;int&gt;vec;
            reverse(vc.begin(),vc.end());
            for(int i:vc){
                vec.push_back(i);
                for(int j=i+1;j&lt;=n&amp;&amp;!vis[j];++j)vec.push_back(j);
            }
            vc=vec;
            vector&lt;pair&lt;int,int&gt; &gt;out;
            int len=1,beg=vc[0];
            for(int i=1;i&lt;(int)vc.size();++i)if(vc[i]==vc[i-1]+1)++len;
            else{
                out.emplace_back(beg,len);
                len=1,beg=vc[i];
            }
            out.emplace_back(beg,len);
            sort(out.begin(),out.end());
            for(auto i:out)cout&lt;&lt;i.second&lt;&lt;&#39; &#39;;
            break;
        }
    }
    return 0;
}
</code></pre>
<hr>
<h1 id="BL"><a href="#BL" class="headerlink" title="BL"></a><div id="BL">BL</div></h1><h2 id="题目大意：-16"><a href="#题目大意：-16" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有 $n$ 天，每天有 $4$ 种可能的不同天气。每天是每种天气的概率分别是 $a,b,c,d$。</p>
<p>那么最终有 $4^n$ 种不同的序列。要求给这 $4^n$ 种不同的序列编上二进制编码，使得任意一个不是另一个的前缀。</p>
<p>求每个序列的最短期望长度。</p>
<h2 id="题解：-16"><a href="#题解：-16" class="headerlink" title="题解："></a>题解：</h2><p>最优编码方式就是哈夫曼编码。哈夫曼编码依据字符出现概率构造，满足“任意一个不是另一个的前缀”且“平均长度最短”。</p>
<p>其构造方式是：每次选两个概率最小的点，将它们连到新的节点上，并删掉，加入新的节点。新的节点概率为原来两个节点的概率之和。</p>
<p>显然可以使用堆来模拟。</p>
<p>对于本题，我们直接计算出每种情况下的概率，然后用堆模拟即可。时间复杂度 $O(4^nn)$。</p>
<p>这一看就不靠谱。</p>
<p>不难发现这些序列中，组成不同的只有 $O(n^3)$ 种。因此我们枚举每种天气的出现次数，并将相同的压在一个节点里存储。用堆模拟时，对于很多相同的节点，可以同时完成合并。</p>
<p>至于计算期望，每次增加一个点的时候，期望长度就增加两个原来的节点的概率之和。容易计算。</p>
<h2 id="Code：-16"><a href="#Code：-16" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define rep(i,a,b)for(int i=(a);i&lt;=(b);++i)
typedef long long LL;
double a,b,c,d,ans;
int n;
LL fac[21];
struct data{
    double g;LL d;
    inline bool operator&lt;(const data&amp;rhs)const{return g&gt;rhs.g;}
};
priority_queue&lt;data&gt;q;
int main(){
    scanf(&quot;%d%lf%lf%lf%lf&quot;,&amp;n,&amp;a,&amp;b,&amp;c,&amp;d);
    for(int i=*fac=1;i&lt;=n;++i)fac[i]=i*fac[i-1];
    rep(A,0,n)rep(B,0,n-A)rep(C,0,n-A-B){
        int D=n-A-B-C;
        double g=pow(a,A)*pow(b,B)*pow(c,C)*pow(d,D);
        LL t=fac[n]/fac[A]/fac[B]/fac[C]/fac[D];
        ans+=g*t;
        q.push((data){g,t});
    }
    while(q.size()){
        data u=q.top();q.pop();
        if(q.empty()&amp;&amp;u.d==1)break;
        if(u.d&gt;1){
            LL k=u.d/2;
            ans+=k*2*u.g;
            q.push((data){u.g*2,k});
            u.d-=k*2;
            if(!u.d)continue;
        }
        data v=q.top();q.pop();
        ans+=u.g+v.g,--v.d;
        q.push((data){u.g+v.g,1});
        if(v.d)q.push(v);
    }
    printf(&quot;%.10f\n&quot;,ans-1);
    return 0;
}
</code></pre>
<hr>
<h1 id="QF"><a href="#QF" class="headerlink" title="QF"></a><div id="QF">QF</div></h1><h2 id="题目大意：-17"><a href="#题目大意：-17" class="headerlink" title="题目大意："></a>题目大意：</h2><p>定义一种语言，它有 <code>for</code> 语句。其格式如下：</p>
<pre><code>for &lt;variable&gt; in range(&lt;from&gt;, &lt;to&gt;):
    &lt;body&gt;
</code></pre><p>该语句会将变量 <code>&lt;variable&gt;</code>从 <code>&lt;from&gt;</code> 迭代到 <code>&lt;to&gt;</code>，每次迭代执行 <code>&lt;body&gt;</code> 中的语句。</p>
<p>若 <code>&lt;from&gt;</code> 大于 <code>&lt;to&gt;</code> 则不会执行 <code>&lt;body&gt;</code>。</p>
<p><code>&lt;from&gt;</code> 可以是变量或 $1$，<code>&lt;to&gt;</code> 可以是变量或 $n$。变量必须之前出现过。</p>
<p>现在给定若干层这样的 <code>for</code> 语句的嵌套，最内层语句为 <code>lag</code>。</p>
<p>定义 $f(n)$ 表示 <code>lag</code> 的执行次数。要求找到 $C,k$ 使得 $C\cdot n^k$ 是程序的渐进复杂度，即满足：</p>
<script type="math/tex; mode=display">
\lim_{n\rightarrow \infty}\frac{f(n)}{C\cdot n^k}=1</script><h2 id="题解：-17"><a href="#题解：-17" class="headerlink" title="题解："></a>题解：</h2><p>考虑 <code>for i in range(a,b):</code> 语句，它规定了 $a\leq i$ 以及 $i\leq b$。</p>
<p>对于 $a\leq b$ 的条件，我们由 $a$ 向 $b$ 连出有向边。如果图上有强连通分量，则这个强连通分量中的点的取值必须相同。</p>
<p>我们将图进行缩点，得到一张 DAG。这张 DAG 中的每个点都是可以在限制范围内任意取值的。因此题目中的 $k$ 就是 DAG 的点数。</p>
<p>对于常数项 $C$，我们只需要知道 DAG 上的 $m$ 个点有多少种不同的大小关系（即图的拓扑序个数），然后除以 $m!$ 即可。</p>
<p>求拓扑序可以使用状压 DP。</p>
<h2 id="Code：-17"><a href="#Code：-17" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=21;
int n;
int id[127],nd=0;
int cnc[N][N],fa[N],e[N],ie[N],ID[N];
long long dp[1&lt;&lt;20];
vector&lt;int&gt;G[N];
inline int find(int x){while(x!=fa[x])x=fa[x]=fa[fa[x]];return x;}
int main(){
    freopen(&quot;fygon20.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;fygon20.out&quot;,&quot;w&quot;,stdout);
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n;--n;
    string s;
    getline(cin,s);
    for(int i=1;i&lt;=n;++i){
        cin&gt;&gt;s;
        getline(cin,s);
        int c=s[1],l=s[12],r=s[15];
        id[c]=nd;
        if(l!=&#39;1&#39;)
            G[id[l]].push_back(nd);
        if(r!=&#39;n&#39;)
            G[nd].push_back(id[r]);
        ++nd;
    }
    getline(cin,s);
    for(int i=0;i&lt;n;++i)for(int t:G[i])
        cnc[i][t]=1;
    for(int k=0;k&lt;n;++k)
        for(int i=0;i&lt;n;++i)
            for(int j=0;j&lt;n;++j)
                cnc[i][j]|=cnc[i][k]&amp;&amp;cnc[k][j];
    for(int i=0;i&lt;n;++i)fa[i]=i;
    for(int i=0;i&lt;n;++i)
        for(int j=i+1;j&lt;n;++j)
            if(cnc[i][j]&amp;&amp;cnc[j][i]){
                int x=find(i),y=find(j);
                if(x!=y)fa[y]=x;
            }
    nd=0;
    for(int i=0;i&lt;n;++i)if(find(i)==i)ID[i]=nd++;
    for(int x=0;x&lt;n;++x){
        int s=ID[find(x)];
        for(int to:G[x]){
            int t=ID[find(to)];
            if(s!=t)
                e[s]|=1&lt;&lt;t,ie[t]|=1&lt;&lt;s;
        }
    }
    const int C=(1&lt;&lt;nd)-1;
    *dp=1;
    for(int S=1;S&lt;=C;++S){
        for(int t=0;t&lt;nd;++t)
            if((S&gt;&gt;t&amp;1)&amp;&amp;(S&amp;ie[t])==ie[t])
                dp[S]+=dp[S^(1&lt;&lt;t)];
    }
    long long p=1,q=dp[C];
    for(int i=2;i&lt;=nd;++i)p*=i;
    long long r=__gcd(p,q);
    p/=r,q/=r;
    cout&lt;&lt;nd&lt;&lt;&#39; &#39;&lt;&lt;q&lt;&lt;&#39;/&#39;&lt;&lt;p&lt;&lt;&#39;\n&#39;;
    return 0;
}
</code></pre>
<hr>
<h1 id="UJ"><a href="#UJ" class="headerlink" title="UJ"></a><div id="UJ">UJ</div></h1><h2 id="题目大意：-18"><a href="#题目大意：-18" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定大小为 $N$ 的向量 $X$。</p>
<p>定义一种 J 语言，有以下几种运算：</p>
<ul>
<li>双目运算（<code>+ - *</code>）：标量与标量运算，结果就是运算结果；向量与标量运算，相当于向量的每一分量与标量运算；向量与向量运算，即对应分量的运算。运算与符号对应的四则运算相同。</li>
<li>单目运算（<code>- *:</code>）：取反和平方（对向量的运算施加到所有分量上）。</li>
<li>仅针对向量的单目运算（<code>+/</code>）：将向量变为一个标量，结果为向量的各分量之和。</li>
</ul>
<p>J 语言只包含这些运算符以及标量 $N$，向量 $X$，且所有运算都从右到左。</p>
<p>现在给你一个结果为标量的 J 语言表达式。输出运算结果对 $10^9$ 取模的值。</p>
<p>本题定义了表达式的 <code>complexity</code>：</p>
<ul>
<li>标量的 <code>complexity</code> 为 $0$。</li>
<li>向量的 <code>complexity</code> 为 $1$。</li>
<li>加法运算和减法运算的 <code>complexity</code> 是，所有参与该运算的表达式的 <code>complexity</code> 的最大值。</li>
<li>乘法的复杂度是，所有参与该运算的表达式的 <code>complexity</code> 的和。</li>
<li>单目平方的复杂度是，参与该运算的表达式的 <code>complexity</code> 的两倍。</li>
</ul>
<p>保证表达式的所有子表达式的 <code>complexity</code> 不超过 $10$。</p>
<h2 id="题解：-18"><a href="#题解：-18" class="headerlink" title="题解："></a>题解：</h2><p>我们维护一个关于 $X$ 的多项式，将标量认为是多项式的常数项。</p>
<p>发现所有运算都相当于多项式的运算。</p>
<p>因此处理出 $X$ 的若干次方的信息，然后表达式计算的时候维护多项式的系数即可。由 <code>complexity</code> 的大小保证了算法的时间复杂度。</p>
<p>由于从右到左运算，因此可以用栈大力模拟。</p>
<h2 id="Code：-18"><a href="#Code：-18" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int md=1e9;
vector&lt;int&gt;X[20];
int n,sum[20];
string expr;
struct data{
    int type;
    string token;
};
struct stk{
    int tp;
    vector&lt;int&gt;A;
};
vector&lt;data&gt;dc;
vector&lt;stk&gt;sk;
void init(){
    for(int i=2;i&lt;20;++i){
        X[i].resize(n);
        for(int x=0;x&lt;n;++x)
        X[i][x]=(LL)X[i-1][x]*X[1][x]%md,sum[i]=(sum[i]+X[i][x])%md;
    }
}
inline int gettype(char c){
    switch(c){
        case&#39;(&#39;:case&#39;)&#39;:case&#39;+&#39;:case&#39;-&#39;:case&#39;*&#39;:case&#39;/&#39;:case&#39;:&#39;:
            return 1;
        case&#39;X&#39;:case&#39;N&#39;:return 2;
    }
    if(isdigit(c))return 3;
    return -1;
}
void work(){
    for(int i=0;i&lt;(int)expr.length();++i){
        int tp=gettype(expr[i]);
        if(tp==1){
            string tk=string(1,expr[i]);
            if(expr[i]==&#39;-&#39;){
                if(dc.empty()||(dc.back().type==1&amp;&amp;dc.back().token!=&quot;)&quot;))
                tk=&quot;$&quot;+tk;
            }else
            if(i+1&lt;(int)expr.length()){
                if(expr[i]==&#39;+&#39;&amp;&amp;expr[i+1]==&#39;/&#39;)
                tk.push_back(expr[++i]);
                else if(expr[i]==&#39;*&#39;&amp;&amp;expr[i+1]==&#39;:&#39;)
                tk.push_back(expr[++i]);
            }
            dc.push_back((data){1,tk});
        }else if(tp==3){
            string tk=string(1,expr[i]);
            while(i+1&lt;(int)expr.length()&amp;&amp;gettype(expr[i+1])==3)
            tk.push_back(expr[++i]);
            dc.push_back((data){3,tk});
        }else{
            dc.push_back((data){2,string(1,expr[i])});
        }
    }
}
void SQR(vector&lt;int&gt;&amp;v){
    vector&lt;int&gt;tmp(2*(int)v.size()-1);
    for(int i=0;i&lt;(int)v.size();++i)
    for(int j=0;j&lt;(int)v.size();++j)
    tmp[i+j]=(tmp[i+j]+(LL)v[i]*v[j])%md;
    v=tmp;
}
void FOLD(vector&lt;int&gt;&amp;v){
    int res=0;
    for(int i=0;i&lt;(int)v.size();++i)
    res=(res+(LL)sum[i]*v[i])%md;
    v.resize(1);
    v[0]=res;
}
void ADD(vector&lt;int&gt;&amp;a,vector&lt;int&gt;b){
    int sz=(int)max(a.size(),b.size());
    a.resize(sz),b.resize(sz);
    for(int i=0;i&lt;sz;++i)a[i]=(a[i]+b[i])%md;
}
void DEL(vector&lt;int&gt;&amp;a,vector&lt;int&gt;b){
    int sz=(int)max(a.size(),b.size());
    a.resize(sz),b.resize(sz);
    for(int i=0;i&lt;sz;++i)a[i]=(a[i]-b[i]+md)%md;
}
void MUL(vector&lt;int&gt;&amp;a,vector&lt;int&gt;b){
    int sz=(int)a.size()+(int)b.size()-1;
    vector&lt;int&gt;tmp(sz);
    for(int i=0;i&lt;(int)a.size();++i)
    for(int j=0;j&lt;(int)b.size();++j)
    tmp[i+j]=(tmp[i+j]+(LL)a[i]*b[j])%md;
    a=tmp;
}
void push_back(stk k){
    while(1){
        if(sk.empty()||sk.back().tp==5)break;
        if(sk.back().tp==1){
            cerr&lt;&lt;&quot;RE&quot;&lt;&lt;&#39;\n&#39;;
            exit(0);
        }
        int tp=sk.back().tp;sk.pop_back();
        if(sk.empty()||sk.back().tp!=1){
            cerr&lt;&lt;&quot;RE&quot;&lt;&lt;&#39;\n&#39;;
            exit(0);
        }
        stk tmp=sk.back();sk.pop_back();
        switch(tp){
            case 2:ADD(k.A,tmp.A);break;
            case 3:DEL(k.A,tmp.A);break;
            case 4:MUL(k.A,tmp.A);
        }
    }
    sk.push_back(k);
}
int calc(){
    for(int i=(int)dc.size()-1;i&gt;=0;--i){
        if(dc[i].type==3){
            int nw=atoi(dc[i].token.c_str());
            vector&lt;int&gt;tmp;
            tmp.push_back(nw);
            push_back((stk){1,tmp});
        }else if(dc[i].type==2){
            vector&lt;int&gt;tmp;
            if(dc[i].token==&quot;X&quot;)
            tmp.push_back(0),tmp.push_back(1);
            else tmp.push_back(n);
            push_back((stk){1,tmp});
        }else{
            if(dc[i].token==&quot;$-&quot;){
                for(int&amp;x:sk.back().A)x=md-x;
            }else if(dc[i].token==&quot;*:&quot;){
                SQR(sk.back().A);
            }else if(dc[i].token==&quot;+/&quot;){
                FOLD(sk.back().A);
            }else if(dc[i].token==&quot;+&quot;){
                sk.push_back((stk){2,vector&lt;int&gt;()});
            }else if(dc[i].token==&quot;-&quot;){
                sk.push_back((stk){3,vector&lt;int&gt;()});
            }else if(dc[i].token==&quot;*&quot;){
                sk.push_back((stk){4,vector&lt;int&gt;()});
            }else if(dc[i].token==&quot;)&quot;){
                sk.push_back((stk){5,vector&lt;int&gt;()});
            }else if(dc[i].token==&quot;(&quot;){
                stk res=sk.back();
                sk.pop_back();
                if(sk.empty()||sk.back().tp!=5){
                    cerr&lt;&lt;&quot;Error!&quot;&lt;&lt;&#39;\n&#39;;
                    exit(0);
                }
                sk.pop_back();
                push_back(res);
            }
        }
    }
    if((int)sk.size()!=1||(int)sk[0].A.size()!=1){
        cerr&lt;&lt;&quot;Wrong!&quot;&lt;&lt;&#39;\n&#39;;
        exit(0);
    }
    return sk[0].A[0];
}
int main(){
    freopen(&quot;j.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;j.out&quot;,&quot;w&quot;,stdout);
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;++i){
        int x;
        cin&gt;&gt;x;
        sum[1]=(sum[1]+x)%md;
        X[1].push_back(x);
        X[0].push_back(1);
    }
    sum[0]=n;
    init();
    cin&gt;&gt;expr;
    work();
    cout&lt;&lt;calc()&lt;&lt;&#39;\n&#39;;
    return 0;
}
</code></pre>
<hr>
<h1 id="NF"><a href="#NF" class="headerlink" title="NF"></a><div id="NF">NF</div></h1><h2 id="题目大意：-19"><a href="#题目大意：-19" class="headerlink" title="题目大意："></a>题目大意：</h2><p>定义 $f_{i,j}$：</p>
<script type="math/tex; mode=display">
f_{i, j} = \begin{cases} l_i & j = 1 \\ t_j & i = 1 \\ a \cdot f_{i, j - 1} + b \cdot f_{i - 1, j} + c & \text{otherwise} \end{cases}</script><p>现在给定 $a,b,c$ 以及 $l_{1..n}$，$t_{1..n}$，求 $f_{n,n}$ 对 $10^6+3$（是个质数）取模的结果。</p>
<h2 id="题解：-19"><a href="#题解：-19" class="headerlink" title="题解："></a>题解：</h2><p><del>被强行灌输了一些高级的数学知识，不过还是可以用简单的方法理解</del></p>
<p>首先考虑 $c=0$ 时的做法。$f_{i,j}=a\cdot f_{i,j-1}+b\cdot f_{i-1,j}$。</p>
<p>考虑式子的组合意义，这是一个经典的格路计数问题，其中向右走贡献乘 $a$，向下走贡献乘 $b$。则从 $(1,1)$ 到 $(m,n)$ 的贡献就是 $\binom{n+m-2}{n-1}\cdot a^{n-1}b^{m-1}$。</p>
<p>由于第一行第一列的初始贡献不同，因此对于每个起点都要计算。时间复杂度 $O(n)$。</p>
<hr>
<p>现在考虑 $c\neq 0$ 的做法。我们希望找到一个办法来消掉常数项 $c$。</p>
<p>考虑找到一个 $x$ 满足 $x=ax+bx+c$，这样就可以得到 $f_{i,j}-x=a\cdot (f_{i,j-1}-x)+b\cdot (f_{i-1,j}-x)$。令 $g_{i,j}=f_{i,j}-x$，将 $g_{n,n}$ 用 $c=0$ 时的做法求出，再加上 $x$ 即可。</p>
<p>容易解得 $x=\frac{c}{1-a-b}$。</p>
<hr>
<p>上面的做法当 $a+b\not\equiv 1\pmod{10^6+3}$ 时是正确的，否则就无法找到这样的 $x$。</p>
<p><del>虽然好像并没有这样的数据但还是要考虑的</del></p>
<p>现在的式子为 $f_{i,j}=a\cdot f_{i,j-1}+(1-a)\cdot f_{i-1,j}+c$。</p>
<p>我们还是想要消掉这个常数 $c$。</p>
<p>注意此时右边两项的系数和为 $1$，且下标和相等，因此我们考虑一个与 $(i+j)$ 有关的函数，为了方便记为 $h_{i,j}$。</p>
<p>令 $h_{i,j}=k(i+j)$，则 $k(i+j)=k(i+j-1)+c$。</p>
<p>解得 $k=c$，即 $h_{i,j}=c(i+j)$。</p>
<p>可以得到 $(f_{i,j}-h_{i,j})=a\cdot(f_{i,j-1}-h_{i,j-1})+(1-a)\cdot(f_{i-1,j}-h_{i-1,j})$。</p>
<p>令 $g_{i,j}=f_{i,j}-h_{i,j}$，将 $g_{n,n}$ 用 $c=0$ 时的做法求出，再加上 $2n\cdot c$ 就是答案。</p>
<p>时间复杂度 $O(n)$。</p>
<h2 id="Code：-19"><a href="#Code：-19" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
typedef long long LL;
const int N=4e5+5,md=1e6+3;
int n,R[N],C[N],a,b,c,A[N],B[N],fac[N],iv[N];
inline int pow(int a,int b){
    int res=1;
    for(;b;b&gt;&gt;=1,a=(LL)a*a%md)if(b&amp;1)res=(LL)res*a%md;
    return res;
}
inline int binom(int n,int m){return(LL)fac[n]*iv[m]%md*iv[n-m]%md;}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n&gt;&gt;a&gt;&gt;b&gt;&gt;c;
    for(int i=*A=*B=*fac=1;i&lt;=2*n;++i)A[i]=(LL)A[i-1]*a%md,B[i]=(LL)B[i-1]*b%md,fac[i]=(LL)fac[i-1]*i%md;
    iv[n]=pow(fac[n],md-2);
    for(int i=n-1;~i;--i)iv[i]=(i+1LL)*iv[i+1]%md;
    for(int i=1;i&lt;=n;++i)cin&gt;&gt;R[i];
    for(int i=1;i&lt;=n;++i)cin&gt;&gt;C[i];
    if((a+b)%md==1){
        int ans=0;
        for(int i=2;i&lt;=n;++i)
        ans=(ans+((LL)A[n-1]*B[n-i]%md*(R[i]-c*(i+1LL)%md+md)+(LL)B[n-1]*A[n-i]%md*(C[i]-c*(i+1LL)%md+md))%md*binom(2*n-i-2,n-2))%md;
        cout&lt;&lt;(ans+2LL*c*n)%md&lt;&lt;&#39;\n&#39;;
    }else{
        int x=c*(LL)pow(2*md+1-a-b,md-2)%md,ans=0;
        for(int i=2;i&lt;=n;++i)
        ans=(ans+((LL)A[n-1]*B[n-i]%md*(R[i]-x+md)+(LL)B[n-1]*A[n-i]%md*(C[i]-x+md))%md*binom(2*n-i-2,n-2))%md;
        cout&lt;&lt;(ans+x)%md&lt;&lt;&#39;\n&#39;;
    }
    return 0;
}
</code></pre>
<hr>
<h1 id="GK"><a href="#GK" class="headerlink" title="GK"></a><div id="GK">GK</div></h1><h2 id="题目大意：-20"><a href="#题目大意：-20" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有 $n$ 个正整数 $a_1,a_2,\ldots,a_n$，满足 $\forall k\in[2,n]$，$\sum\limits_{i=1}^{k-1}a_i \lt a_k$，且 $\sum\limits_{i=1}^n a_i\leq 2^{64}$。还有一个奇数 $r$。</p>
<p>现在给你 $n$ 以及 $b_1,b_2,\ldots,b_n$，其中 $b_i=a_i\cdot r\bmod{2^{64}}$。</p>
<p>再给你整数 $s$，要求从 $n$ 个数中选出若干个 $b_i$ 使得它们的和模 $2^{64}$ 恰好为 $s$。</p>
<p>保证有解。</p>
<p>$1\leq n\leq 64$，$1\leq b_i,r\lt 2^{64}$，$0\leq s\lt 2^{64}$。</p>
<h2 id="题解：-20"><a href="#题解：-20" class="headerlink" title="题解："></a>题解：</h2><p>用若干个 $b_i$ 拼出 $s$，相当于用若干个 $a_i$ 拼出 $\frac{s}r$，由题目条件可知解唯一。</p>
<p>我们考虑以下两个算法：</p>
<ul>
<li><p>将 $n$ 个数分成 $\lfloor\frac n 2\rfloor$ 个和 $\lceil\frac n 2\rceil$ 个的两组，对每组中的每个子集计算和。再枚举其中一组的所有子集，并快速判断另一组中有无集合的和与当前的和加起来恰好为 $s$。</p>
<p>即 Meet in the middle。</p>
<p>可以使用哈希表做到 $O(2^{n/2})$ 的复杂度。</p>
</li>
<li><p>发现 $b_i$ 是与 $a_i$ 对应的，因此考虑枚举 $a_1$ 的取值，并解出 $r$，从而解出 $a’_2,a’_3,\ldots,a’_n$。</p>
<p>判断 $a’$ 是否满足题目中的限制条件。若满足则从大到小枚举 $a’$，并贪心地选取，即可得到方案。</p>
<p>考虑该算法的复杂度。由题目条件可知，$a_i&gt;2a_{i-1}$，从而可以推出 $a_1$ 最大不超过 $2^{64-n}$。</p>
<p>因此复杂度为 $O(2^{64-n}\cdot n)$。</p>
<p>不过这里我们要考虑一些细节。</p>
<p>我们在求解 $r$ 的时候，是根据 $a_1\cdot r\equiv b_1\pmod{2^{64}}$。</p>
<p>令 $k=\texttt{<strong>builtin_ctz}(b_1)$（即 $b_1$ 二进制末尾 $0$ 的个数）。由于 $r$ 是奇数，故 $\texttt{</strong>builtin_ctz(a_1)}=k$ 成立。</p>
<p>将等式两边同时除以 $2^k$ 后得 $a_1\cdot r\cdot 2^{-k}=b_1\cdot 2^{-k}\pmod{2^{64-k}}$。</p>
<p>因此我们得到的 $r$ 只能保证前 $64-k$ 位是正确的。</p>
<p>那么我们还需要枚举后面的 $k$ 位。</p>
<p>看上去复杂度会变高的样子。注意到 $a_1$ 末尾要有<strong>恰好</strong> $k$ 个 $0$，因此我们枚举的时候每次加上 $2^{k+1}$ 即可。这样算上枚举后面 $k$ 的复杂度，仍然是 $O(2^{64-n}\cdot n)$ 的。</p>
</li>
</ul>
<p>两种算法分别在 $n$ 较小和 $n$ 较大时有着良好的表现，因此我们设一个阈值 $B$，当 $n\leq B$ 时使用算法一，当 $n&gt;B$ 时使用算法 $2$。</p>
<p>$B$ 约为 $42$ 左右较优。</p>
<h2 id="Code：-20"><a href="#Code：-20" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
#define int uint64_t
int b[64],n,s,d[64];
unordered_map&lt;int,int&gt;mp;
void solve1(){
    int _=n/2,__=n-_;
    for(int32_t i=0;i&lt;(1&lt;&lt;_);++i){
        int s=0;
        for(int j=0;j&lt;_;++j)if(i&gt;&gt;j&amp;1)s+=b[j];
        mp[s]=i;
    }
    for(int32_t i=0;i&lt;(1&lt;&lt;__);++i){
        int t=0;
        for(int j=0;j&lt;__;++j)if(i&gt;&gt;j&amp;1)t+=b[_+j];
        if(mp.count(s-t)){
            int k=mp[s-t]|((int)i&lt;&lt;_);
            for(int h=0;h&lt;n;++h)cout.put((k&gt;&gt;h&amp;1)^&#39;0&#39;);
            return;
        }
    }
}
inline int inv(int b){
    int res=1,k=b;
    for(int i=1;i&lt;64;++i)
    if(k&gt;&gt;i&amp;1)k+=b&lt;&lt;i,res|=1llu&lt;&lt;i;
    return res;
}
bool chk(){
    int res=d[0];
    for(int i=1;i&lt;n;++i){
        if(res&gt;=d[i]||res&gt;=-d[i])return 0;
        res+=d[i];
    }
    return 1;
}
void solve2(){
    int _=b[0]&amp;-b[0],__=__builtin_ctzll(_);
    for(d[0]=_;;d[0]+=_&lt;&lt;1){
        int iv=d[0]/_*inv(b[0]/_);
        for(int c=0;c&lt;_;++c){
            for(int i=1;i&lt;n;++i)d[i]=b[i]*iv;
            if(chk()){
                s*=iv;
                int ans=0;
                for(int i=n-1;~i;--i)if(s&gt;=d[i])ans|=1llu&lt;&lt;i,s-=d[i];
                for(int i=0;i&lt;n;++i)cout.put((ans&gt;&gt;i&amp;1)^&#39;0&#39;);
                return;
            }
            iv+=1llu&lt;&lt;(64-__);
        }
    }
}
main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n;
    for(int i=0;i&lt;n;++i)cin&gt;&gt;b[i];
    cin&gt;&gt;s;
    if(n&lt;=42)solve1();
    else solve2();
    return 0;
}
</code></pre>
<hr>
<h1 id="LK"><a href="#LK" class="headerlink" title="LK"></a><div id="LK">LK</div></h1><h2 id="题目大意：-21"><a href="#题目大意：-21" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有 $n$ 个旋钮，每个旋钮上有 $7$ 个数字，指针恰好指向其中一个数字。这个旋钮表示的数是从指针开始顺时针将所有数字依次排列得到的数。</p>
<p>你现在每次可以选择一段区间的旋钮，将它们任意旋转同一个角度（必须保证指针仍指向一个数字）。</p>
<p>要求使用最少的操作，使得每个旋钮表示的数都是它能表示的最大的数。求最小操作次数。</p>
<p>$n\leq 500$。</p>
<h2 id="题解：-21"><a href="#题解：-21" class="headerlink" title="题解："></a>题解：</h2><p>一个旋钮要么怎么转的大小都是一样，要么恰有一个最大数。我们可以把怎么转都一样的旋钮去掉不考虑。</p>
<p>以下运算默认都在模 $7$ 意义下进行。</p>
<p>记录 $a_i$ 表示旋钮 $i$ 顺时针旋转到最大值所需转过的数字个数。那么一次旋转相当于区间加。</p>
<p>记录 $b_i$ 表示 $a_i-a_{i-1}$。则一次旋转相当于选 $i,j,k$，令 $b_i$ 加上 $k$，$b_j$ 减去 $k$。</p>
<p>那么我们就是要将 $b$ 分成若干组，使得每组的和为 $0$。设分成了 $k$ 组，那么不难发现需要 $n-k$ 次操作。</p>
<p>所以要最大化 $k$。</p>
<p>首先去掉 $b_i=0$ 的数，然后将 $1$ 和 $6$， $2$ 和 $5$，$3$ 和 $4$ 尽可能匹配（先匹配掉一定优）。</p>
<p>剩下的还有最多三种数，我们可以 dp 求解。</p>
<p>令 $f_{i,j,k,t}$ 表示三种数分别为 $i,j,k$，最后一组模 $7$ 余 $t$ 时所需的最少操作次数。转移枚举选哪个即可。</p>
<p>时间复杂度 $O(n^3)$。</p>
<h2 id="Code：-21"><a href="#Code：-21" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=505;
int n,a[N],b[N],ans,tot[8];
string s;
int A[4],B[4],m;
inline void upd(int&amp;a,int b){a=a&lt;b?b:a;}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n;
    for(int i=1;i&lt;=n;++i){
        cin&gt;&gt;s;
        string t=s;
        t.erase(t.begin()),t+=s[0];
        if(s==t)--n,--i;
        else{
            t=s,a[i]=0;
            for(int j=1;j&lt;7;++j){
                s+=s[0],s.erase(s.begin());
                if(s&gt;t)t=s,a[i]=j;
            }
        }
        b[i]=(a[i]-a[i-1]+7)%7;
    }
    b[n+1]=(7-a[n])%7;
    if(!n)return cout&lt;&lt;&quot;0\n&quot;,0;
    ans=++n;
    for(int i=1;i&lt;=n;++i)++tot[b[i]];
    ans-=*tot;
    for(int i=1;i&lt;4;++i){
        int x=min(tot[i],tot[7-i]);
        tot[i]-=x,tot[7-i]-=x,ans-=x;
    }
    for(int i=1;i&lt;7;++i)if(tot[i])
    A[++m]=i,B[m]=tot[i];
    int dp[B[1]+2][B[2]+2][B[3]+2][7];
    memset(dp,-1,(B[1]+2)*(B[2]+2)*(B[3]+2)*28);
    dp[B[1]][B[2]][B[3]][0]=0;
    for(int i=B[1];~i;--i)
    for(int j=B[2];~j;--j)
    for(int k=B[3];~k;--k)
    for(int t=0;t&lt;7;++t){
        int x=dp[i][j][k][t];
        if(x!=-1){
            int f=(t+A[1])%7,g=(t+A[2])%7,h=(t+A[3])%7;
            if(i)upd(dp[i-1][j][k][f],x+!f);
            if(j)upd(dp[i][j-1][k][g],x+!g);
            if(k)upd(dp[i][j][k-1][h],x+!h);
        }
    }
    ans-=****dp;
    cout&lt;&lt;ans&lt;&lt;&#39;\n&#39;;
    return 0;
}
</code></pre>
<hr>
<h1 id="IJ"><a href="#IJ" class="headerlink" title="IJ"></a><div id="IJ">IJ</div></h1><h2 id="题目大意：-22"><a href="#题目大意：-22" class="headerlink" title="题目大意："></a>题目大意：</h2><p>这是一道 IO 交互题。</p>
<p>给定长度为 $n$（$n$ 为偶数） 的 01 字符串 $S$。</p>
<p>你可以向交互库进行询问。你可以向交互库输出一个长度为 $n$ 的 01 字符串 $Q$。设 $S$ 和 $Q$ 有 $k$ 个对应的位置上的字符相同。若 $k=n$ 或 $k=\frac n 2$，则交互库将返回 $k$，否则交互库将返回 $0$。</p>
<p>你最多向交互库询问 $n+500$ 次，要求求出 $S$。你只需要使最后一次询问的返回值为 $n$ 即可。</p>
<h2 id="题解：-22"><a href="#题解：-22" class="headerlink" title="题解："></a>题解：</h2><p>考虑一个上限为 $2n$ 次询问的构造。</p>
<p>随便找一个 01 串 $t$，从前往后依次翻转（之前的翻转对之后生效），直到询问出一个 $\frac n 2$ 的。这里只需要不超过 $n-1$ 次询问。</p>
<p>假设一开始有 $k$ 个位置相等，则最后一次有 $n-k$ 个位置相等，翻转一个位置只会使 $k$ 增加或减少 $1$。而 $\frac n 2$ 在它们中间，所以一定有一个位置是 $\frac n 2$。</p>
<p>现在 $t$ 已经有 $\frac n 2$ 个位置正确了。</p>
<p>然后枚举位置 $i$，翻转 $i$ 和 $i+1$（仅这次询问翻转）并询问。若结果为 $0$，则这两个位置同时正确或错误。若结果为 $\frac n 2$，则这两个位置有一个正确，另一个错误。</p>
<p>有了所有相邻两个的信息，我们只需要确定一个位置就可以推出所有的位置。再花 $2$ 次询问即可。</p>
<hr>
<p>我们来算一下恰好有 $\frac n 2$ 位正确的字符串的占比，为 $\frac{\binom{n}{n/2}}{2^n}$。当 $n=1000$ 时，用 Ubuntu 20.04 下的计算器计算出来的结果为 $0.025225018$。那我们随机 $499$ 次都随不到一个这样的串的概率为 $(1-0.025225018)^{499}\approx0.000002906$。</p>
<p>这个概率非常地小，所以我们直接随机得到一个恰有 $\frac n 2$ 个位置正确的串即可，并不需要那个 $n-1$ 次的构造方案了。</p>
<h2 id="Code：-22"><a href="#Code：-22" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=1005;
int n;
bool df[N];
char s[N];
int main(){
    srand(time(0)+(size_t)new int);
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n;
    for(int i=1,r;;++i){
        for(int j=0;j&lt;n;++j)s[j]=(rand()&amp;1)+&#39;0&#39;;
        cout&lt;&lt;s&lt;&lt;endl;
        cin&gt;&gt;r;
        if(r==n)return 0;
        if(r==n/2)break;
    }
    for(int i=0,r;i+1&lt;n;++i){
        s[i]^=1,s[i+1]^=1;
        cout&lt;&lt;s&lt;&lt;endl;
        cin&gt;&gt;r;
        if(r==n)return 0;
        df[i]=(r==n/2)^(s[i]!=s[i+1]);
        s[i]^=1,s[i+1]^=1;
    }
    int r;
    s[0]=&#39;0&#39;;
    for(int i=1;i&lt;n;++i)s[i]=s[i-1]^df[i-1];
    cout&lt;&lt;s&lt;&lt;endl;
    cin&gt;&gt;r;
    if(r==n)return 0;
    for(int i=0;i&lt;n;++i)s[i]^=1;
    cout&lt;&lt;s&lt;&lt;endl;
    cin&gt;&gt;r;
    if(r!=n)return 1;
    return 0;
}
</code></pre>
<hr>
<h1 id="IB"><a href="#IB" class="headerlink" title="IB"></a><div id="IB">IB</div></h1><h2 id="题目大意：-23"><a href="#题目大意：-23" class="headerlink" title="题目大意："></a>题目大意：</h2><p>求第 $n$ 个不含前导 $0$ 的正整数，满足它的十进制表示是它的二进制表示的后缀。称这样的数为二又十进制数。</p>
<p>$n\leq 10^4$。</p>
<h2 id="题解：-23"><a href="#题解：-23" class="headerlink" title="题解："></a>题解：</h2><p>大胆猜测第 $10^4$ 个二又十进制数的位数并不会非常大（事实上最大时只有约 $200$ 位），因此可以考虑一种方式进行搜索。</p>
<p>一个比较方便的做法是按照数在十进制下的位数从小到大进行 BFS。</p>
<p>那么我们如何扩展状态呢？</p>
<p>假设当前十进制下有 $k$ 位，那么新加的一位是 $10^k$，而二进制上新加的一位是 $2^k$。由于 $10^k$ 必定是 $2^k$ 的倍数，因此不会导致二进制表示下的后缀产生变化。</p>
<p>然后我们只需要判断一下新的数模 $2^{k+1}$ 是否等于该数“对应”的二进制数即可。</p>
<p>当然也需要把没加 $10^k$ 的含前导 $0$ 的数放入队列，用于在之后的位上添加 $1$。</p>
<p>由于在搜索同一个位数的时候没有安装数的大小顺序，因此需要搜出较多个数以后，再排序输出第 $n$ 个。</p>
<p>由于可能涉及到的高精度运算，代码使用 Java 实现。</p>
<h2 id="Code：-23"><a href="#Code：-23" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-java">import java.util.*;
import java.math.*;
import java.io.*;
public class Main{
    static int n;
    static BigInteger _2[]=new BigInteger[205],_10[]=new BigInteger[205];
    public static class data{
        BigInteger decimal,binary;
        int w;
        boolean zero;
        data(){}
        data(BigInteger dec,BigInteger bin,int ww,boolean zr){
            decimal=dec;
            binary=bin;
            w=ww;
            zero=zr;
        }
    }
    static data q[]=new data[100005];
    static ArrayList res=new ArrayList();
    public static void main(String args[]){
        try{
            System.setIn(new FileInputStream(&quot;binary.in&quot;));
        }catch(FileNotFoundException fnfe){
            System.out.println(fnfe.getMessage());
        }
        try{
            System.setOut(new PrintStream(&quot;binary.out&quot;));
        }catch(FileNotFoundException fnfe){
            System.out.println(fnfe.getMessage());
        }
        Scanner in=new Scanner(System.in);
        n=in.nextInt();
        _2[0]=_10[0]=BigInteger.valueOf(1);
        for(int i=1;i&lt;=200;++i){
            _2[i]=_2[i-1].multiply(BigInteger.valueOf(2));
            _10[i]=_10[i-1].multiply(BigInteger.valueOf(10));
        }
        int h=1,t=0;
        q[++t]=new data(BigInteger.valueOf(0),BigInteger.valueOf(0),0,false);
        q[++t]=new data(BigInteger.valueOf(1),BigInteger.valueOf(1),0,true);
        int cnt=0;
        while(h&lt;=t){
            data x=q[h++];
            if(x.zero)res.add(cnt++,x.decimal);
            if(cnt==16384)break;
            ++x.w;
            x.zero=false;
            if(x.decimal.remainder(_2[x.w+1]).compareTo(x.binary)==0)
                q[++t]=new data(x.decimal,x.binary,x.w,x.zero);
            x.decimal=x.decimal.add(_10[x.w]);
            x.binary=x.binary.add(_2[x.w]);
            x.zero=true;
            if(x.decimal.remainder(_2[x.w+1]).compareTo(x.binary)==0)
                q[++t]=new data(x.decimal,x.binary,x.w,x.zero);;
        }
        Collections.sort(res);
        System.out.println((BigInteger)res.get(n-1));
    }
}
</code></pre>
<hr>
<h1 id="TK"><a href="#TK" class="headerlink" title="TK"></a><div id="TK">TK</div></h1><h2 id="题目大意：-24"><a href="#题目大意：-24" class="headerlink" title="题目大意："></a>题目大意：</h2><p>你有 $n$ 个烤肉串要<strong>依次</strong>烤。你在做烤肉串的时候可能会做白日梦，任意连续 $t+1$ 秒内你只能有 $1$ 秒做白日梦。</p>
<p>第 $i$ 个烤肉串要加 $q_i$ 单位原料，加入 $1$ 单位原料要花 $1$ 秒。做白日梦时会少加入 $1$ 单位原料。客人对第 $i$ 个烤肉串的最少原料需求是 $x_i$，也就是说做第 $i$ 个烤肉串的时候最多能做 $q_i-t_i$ 秒的白日梦。</p>
<p>求有多少种不同的做白日梦的方案，使得客人对所有烤肉串满意。</p>
<p>$1\leq n\leq 1000$，$0\leq t\leq 100$，$1\le q_i\leq 250$，$0\leq x_i\leq q_i$。</p>
<h2 id="题解：-24"><a href="#题解：-24" class="headerlink" title="题解："></a>题解：</h2><p>总时长为 $\sum_i q_i\leq 250000$，考虑直接对每个时刻进行 dp。</p>
<p>令 $dp_{i,j}$ 表示第 $i$ 个时刻结束后，当前烤肉串已经做了 $j$ 秒白日梦时的方案数。</p>
<p>转移有两种：不做白日梦和做白日梦，分别从第 $i-1$ 秒和第 $i-t-1$ 秒转移过来。</p>
<p>如果被转移的状态的烤肉串和当前烤肉串不同，则 $j$ 需重新计，否则 $j$ 不能超过这个烤肉串的上限。</p>
<p>时空复杂度 $O(nq^2)$。常数较小，在时空上都没有压力。</p>
<h2 id="Code：-24"><a href="#Code：-24" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=250005,md=1e9+7;
typedef long long LL;
int n,t,bel[N],A[1234],B[1234],m;
int dp[N][251],sum[N];
int main(){
    freopen(&quot;kebab.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;kebab.out&quot;,&quot;w&quot;,stdout);
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    cin&gt;&gt;n&gt;&gt;t;
    for(int i=1;i&lt;=n;++i){
        cin&gt;&gt;A[i]&gt;&gt;B[i];
        for(int j=1;j&lt;=A[i];++j)
        bel[m+j]=i;
        m+=A[i];
    }
    sum[0]=dp[0][0]=1;
    for(int i=1;i&lt;=m;++i){
        int x=bel[i],lm=A[x]-B[x];
        dp[i][0]=dp[i-1][0];
        if(bel[i-1]!=bel[i])
        dp[i][0]=sum[i-1];
        int pv=max(0,i-t-1);
        if(bel[pv]!=x&amp;&amp;lm)dp[i][1]=((bel[i-1]==x)*dp[i-1][1]+sum[pv])%md;
        else{
            for(int j=1;j&lt;=lm;++j)
            dp[i][j]=((bel[i-1]==x)*dp[i-1][j]+dp[pv][j-1])%md;
        }
        for(int j=0;j&lt;=lm;++j)sum[i]=(dp[i][j]+sum[i])%md;
    }
    cout&lt;&lt;sum[m]&lt;&lt;&#39;\n&#39;;
    return 0;
}
</code></pre>
<hr>
<h1 id="PD"><a href="#PD" class="headerlink" title="PD"></a><div id="PD">PD</div></h1><h2 id="题目大意：-25"><a href="#题目大意：-25" class="headerlink" title="题目大意："></a>题目大意：</h2><p>有 $n$ 个站点和 $m$ 条线路。每条线路经过若干个站点（不重复），且都是双向的。</p>
<p>坐在一条线路上从一个站点到另一个站点需要 $1$ 分钟。换乘不需要时间（从一条线路到它的相反方向也要换乘）。</p>
<p>现在需要从 $s$ 走到 $t$，求最少的换乘次数和在此基础上花费的最多时间。</p>
<p>$n\leq 3\times 10^5$，$m\leq 10^5$，线路总长 $\leq 10^6$。</p>
<p>输入格式比较烦。</p>
<h2 id="题解：-25"><a href="#题解：-25" class="headerlink" title="题解："></a>题解：</h2><p>主要是对输入的处理。</p>
<p>由于站点名中没有空格，因此使用 cin 直接读入还是比较方便的。以读一条线路为例，先把开头读掉，然后一直读直到末尾不是逗号为止。</p>
<p>对于最少换乘次数，直接建图跑最短路即可。由于只有 01 边权所以可以直接使用队列（我还是使用了优先队列）。</p>
<p>然后我们按照换乘次数对图进行分层，只保留相邻两层和同层中的有向边。</p>
<p>由于只有在换乘的时候跨层，而同层中的边都是线路上的有向边，因此不难发现是个有向无环图。</p>
<p>使用 BFS 按照拓扑排序的方式求最长路即可。</p>
<h2 id="Code：-25"><a href="#Code：-25" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;bits/stdc++.h&gt;
using namespace std;
const int N=2e6+5;
typedef uint64_t LL;
map&lt;string,int&gt;mp;
int T;
string s,station[N];
int n,k,c,head[N],cnt,st,ed;
pair&lt;int,int&gt;dis[N];
inline pair&lt;int,int&gt;operator+(const pair&lt;int,int&gt;&amp;a,const pair&lt;int,int&gt;&amp;b){
    return make_pair(a.first+b.first,a.second+b.second);
}
struct edge{
    int to,nxt;pair&lt;int,int&gt;w;
}e[N*3];
inline void addedge(int u,int v,pair&lt;int,int&gt;w){e[++cnt]=(edge){v,head[u],w},head[u]=cnt;}
struct data{
    int u;pair&lt;int,int&gt;d;
    inline bool operator&lt;(const data&amp;rhs)const{return d&gt;rhs.d;}
};
priority_queue&lt;data&gt;q;
void Kosaraju(){
    for(int i=1;i&lt;=k;++i)dis[i]=make_pair(0x3f3f3f3f,0x3f3f3f3f);
    dis[st]=make_pair(0,0);
    q.push((data){st,dis[st]});
    while(q.size()){
        data w=q.top();q.pop();
        int u=w.u;
        if(dis[u]!=w.d)continue;
        for(int i=head[u];i;i=e[i].nxt)
            if(dis[e[i].to]&gt;dis[u]+e[i].w){
                dis[e[i].to]=dis[u]+e[i].w;
                q.push((data){e[i].to,dis[e[i].to]});
            }
    }
}
queue&lt;int&gt;p;
bool vis[N];
int deg[N];
void Johnson(){
    for(int x=1;x&lt;=k;++x)
    for(int i=head[x];i;i=e[i].nxt)if(dis[e[i].to].first==dis[x].first+e[i].w.first)
    ++deg[e[i].to];
    for(int i=1;i&lt;=k;++i)if(!deg[i])p.push(i);
    while(p.size()){
        int u=p.front();p.pop();
        for(int i=head[u];i;i=e[i].nxt)
        if(dis[e[i].to].first==dis[u].first+e[i].w.first){
            dis[e[i].to].second=max(dis[e[i].to].second,dis[u].second+e[i].w.second);
            if(!--deg[e[i].to])p.push(e[i].to);
        }
    }
}
int main(){
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
    for(cin&gt;&gt;T;T--;){
        memset(head,0,sizeof head),cnt=0;
        mp.clear();
        n=c=0;
        cin&gt;&gt;s;
        for(;;){
            bool ok=1;
            cin&gt;&gt;s;
            if(s.back()==&#39;,&#39;)
                ok=0,s.pop_back();
            station[++n]=s;
            mp[s]=n;
            if(ok)break;
        }
        k=n;
        cin&gt;&gt;s;
        for(;;){
            bool ok=1;
            cin&gt;&gt;s;
            if(s.back()==&#39;,&#39;)
                ok=0,s.pop_back();
            ++c;
            if(ok)break;
        }
        while(c--){
            cin&gt;&gt;s&gt;&gt;s;
            static int id[N],_[N];
            int tot=0;
            for(;;){
                bool ok=1;
                cin&gt;&gt;s;
                if(s.back()==&#39;,&#39;)
                    ok=0,s.pop_back();
                id[++tot]=mp[s];
                if(ok)break;
            }
            for(int i=1;i&lt;=tot;++i){
                _[i]=++k;
                addedge(id[i],_[i],make_pair(1,0));
                addedge(_[i],id[i],make_pair(0,0));
            }
            for(int i=1;i&lt;tot;++i)
                addedge(_[i],_[i+1],make_pair(0,1));
            for(int i=1;i&lt;=tot;++i){
                _[i]=++k;
                addedge(id[i],_[i],make_pair(1,0));
                addedge(_[i],id[i],make_pair(0,0));
            }
            for(int i=tot;i&gt;1;--i)
                addedge(_[i],_[i-1],make_pair(0,1));
        }
        cin&gt;&gt;s&gt;&gt;s&gt;&gt;s&gt;&gt;s;
        st=mp[s];
        cin&gt;&gt;s&gt;&gt;s&gt;&gt;s&gt;&gt;s;
        ed=mp[s];
        Kosaraju();
        Johnson();
        int A=dis[ed].second,B=dis[ed].first;
        cout&lt;&lt;&quot;optimal travel from &quot;+station[st]+&quot; to &quot;+station[ed]+&quot;: &quot;
            &lt;&lt;B&lt;&lt;(B==1?&quot; line, &quot;:&quot; lines, &quot;)&lt;&lt;A&lt;&lt;(A==1?&quot; minute\n&quot;:&quot; minutes\n&quot;);
    }
    return 0;
}
</code></pre>
<hr>
<h1 id="QG"><a href="#QG" class="headerlink" title="QG"></a><div id="QG">QG</div></h1><h2 id="题目大意：-26"><a href="#题目大意：-26" class="headerlink" title="题目大意："></a>题目大意：</h2><p>给定一张 $n$ 个点 $m$ 条边的简单无向图，要求找到两个不同的点 $s,t$，满足它们之间有三条不经过重复边、除了起点和终点不经过重复点的路径。</p>
<p>如果有则输出一种方案，没有则输出 <code>-1</code>。</p>
<p>$n,m\leq 10^5$。</p>
<h2 id="题解：-26"><a href="#题解：-26" class="headerlink" title="题解："></a>题解：</h2><p>见<a href="/CF521E/">CF521E</a>。</p>
<h2 id="Code：-26"><a href="#Code：-26" class="headerlink" title="Code："></a>Code：</h2><pre><code class="lang-c++">#include&lt;cstdio&gt;
#include&lt;cstdlib&gt;
#include&lt;vector&gt;
const int N=2e5+6;
struct edge{
    int to,nxt;
    bool vis;
}e[N&lt;&lt;1];
int head[N],cnt,n,m,dep[N],fa[N],up[N];
bool vis[N],isret;
std::vector&lt;int&gt;out;
void O_R(int now,const int&amp;ed){
    if(now!=ed)O_R(fa[now],ed);
    out.push_back(now);
}
void output(){
    printf(&quot;%d&quot;,(int)out.size());
    for(int i=0;i&lt;(int)out.size();++i)printf(&quot; %d&quot;,out[i]);
    putchar(&#39;\n&#39;);
    out.clear();
}
void DFS(int now,int pre){
    if(isret)return;
    vis[now]=1;
    for(int i=head[now];i;i=e[i].nxt)
    if(i!=pre&amp;&amp;!vis[e[i].to]){
        e[i].vis=1;
        dep[e[i].to]=dep[now]+1;
        fa[e[i].to]=now;
        DFS(e[i].to,i^1);
        if(isret)return;
    }else
    if(dep[e[i].to]&lt;dep[now]&amp;&amp;i!=pre){
        if(!up[now])up[now]=e[i].to;
        else{
            int u=up[now],v=e[i].to;
            if(dep[u]&lt;dep[v])u^=v^=u^=v;
            out.push_back(now);
            for(int s=now;s!=u;s=fa[s])out.push_back(fa[s]);
            printf(&quot;%d %d\n&quot;,out[0],out.back());
            output();
            printf(&quot;2 %d %d\n&quot;,now,u);
            out.push_back(now);
            O_R(u,v);
            output();
            isret=1;return;
        }
    }
}
int dfs(int now){
    if(isret)return 0;
    int res=up[now]?now:0;
    for(int i=head[now];i;i=e[i].nxt)
    if(e[i].vis){
        int t=dfs(e[i].to);
        if(isret)return 0;
        if(up[t]==now)t=0;
        if(res&amp;&amp;t){
            int u=up[res],v=up[t];
            if(dep[u]&lt;dep[v])u^=v^=u^=v,res^=t^=res^=t;
            O_R(res,now),out.push_back(u);
            printf(&quot;%d %d\n&quot;,out[0],out.back());
            output();
            out.push_back(now);
            for(int s=now;s!=u;s=fa[s])out.push_back(fa[s]);
            output();
            O_R(t,now),O_R(u,v);
            output();
            isret=1;return 0;
        }else if(t)res=t;
    }
    return res;
}
int main(){
    int T;
    freopen(&quot;grand.in&quot;,&quot;r&quot;,stdin);
    freopen(&quot;grand.out&quot;,&quot;w&quot;,stdout);
    for(scanf(&quot;%d&quot;,&amp;T);T--;){
        isret=0;
        for(int i=1;i&lt;=n;++i)head[i]=fa[i]=up[i]=dep[i]=0,vis[i]=0;
        cnt=1;
        scanf(&quot;%d%d&quot;,&amp;n,&amp;m);
        for(int i=1;i&lt;=m;++i){
            int u,v;
            scanf(&quot;%d%d&quot;,&amp;u,&amp;v);
            e[++cnt]=(edge){v,head[u]},head[u]=cnt;
            e[++cnt]=(edge){u,head[v]},head[v]=cnt;
        }
        for(int i=1;i&lt;=n;++i)if(!dep[i])dep[i]=1,DFS(i,0);
        for(int i=1;i&lt;=n;++i)if(dep[i]==1)dfs(i);
        if(!isret)puts(&quot;-1&quot;);
    }
    return 0;
}
</code></pre>

        
    

    
</div>


                

                <!-- Post Comments -->
                
                    
    <!-- 使用 Gitalk -->
<div id="gitalk-comment">
    <!-- Gitalk 评论框 -->
<div id="gitalk-container"></div>

<link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css">

<script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>

<script>
    var gitalk = new Gitalk({
            clientID: '3b1c25bc36babcc685f2',
            clientSecret: '2ab0b0464d9a1f774a6dd652da7b34de0ad6d6f5',
            repo: 'talking',
            owner: 'mrsrz',
            admin: ['mrsrz'],
            // facebook-like distraction free mode
            distractionFreeMode: false
        })
   gitalk.render('gitalk-container')
</script>
</div>
<style>
    #gitalk-comment {
        background-color: #eee;
        padding: 2pc;
    }
</style>


                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/Ynoi2008-rplexq/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>




                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/side.jpg);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/head.png" alt="mrsrz's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        1473200830@qq.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="#" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2020/10/">十月 2020<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/09/">九月 2020<span class="sidebar_archives-count">24</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/07/">七月 2020<span class="sidebar_archives-count">4</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/06/">六月 2020<span class="sidebar_archives-count">3</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/04/">四月 2020<span class="sidebar_archives-count">22</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/03/">三月 2020<span class="sidebar_archives-count">47</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/02/">二月 2020<span class="sidebar_archives-count">42</span></a></li><li><a class="sidebar_archives-link" href="/archives/2020/01/">一月 2020<span class="sidebar_archives-count">52</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/12/">十二月 2019<span class="sidebar_archives-count">31</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/11/">十一月 2019<span class="sidebar_archives-count">54</span></a></li><li><a class="sidebar_archives-link" href="/archives/2019/10/">十月 2019<span class="sidebar_archives-count">33</span></a>
            </ul>
        </li>
        
            <li class="divider"></li>
        
    

    <!-- Categories  -->
    

    <!-- Pages  -->
    
        <li>
            <a href="/tags" title="标签">
                
                    <i class="material-icons sidebar-material-icons">tab</i>
                
                标签
            </a>
        </li>
        
    
        <li>
            <a href="/about" title="关于">
                
                    <i class="material-icons sidebar-material-icons">person</i>
                
                关于
            </a>
        </li>
        
    
        <li>
            <a href="/links" title="友链">
                
                    <i class="material-icons sidebar-material-icons">face</i>
                
                友链
            </a>
        </li>
        
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            主题 - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div id="back-to-top" class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    

    <!-- Facebook -->
    

    <!-- Google + -->
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    
        <a href="https://github.com/mrsrz" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-github">
                <span class="visuallyhidden">Github</span>
            </button><!--
     --></a>
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    
        <a href="https://www.zhihu.com/people/mrsrz" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn footer-sns-zhihu">
                <span class="visuallyhidden">Zhihu</span>
            </button><!--
     --></a>
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
    
    <!-- V2EX -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;2019&nbsp;-<script type="text/javascript">var fd = new Date();document.write("&nbsp;" + fd.getFullYear() + "&nbsp;");</script>Mrsrz's blog
            
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import JS File -->

    <script>lsloader.load("lazyload_js","/js/lazyload.min.js?1BcfzuNXqV+ntF6gq+5X3Q==", true)</script>



    <script>lsloader.load("js_js","/js/js.min.js?V/53wGualMuiPM3xoetD5Q==", true)</script>



    <script>lsloader.load("np_js","/js/nprogress.js?pl3Qhb9lvqR1FlyLUna1Yw==", true)</script>


<script type="text/ls-javascript" id="NProgress-script">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>









   <!-- GitTalk -->





<!-- UC Browser Compatible -->
<script>
	var agent = navigator.userAgent.toLowerCase();
	if(agent.indexOf('ucbrowser')>0) {
		document.write('<link rel="stylesheet" href="/css/uc.css">');
	   alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
	}
</script>

<!-- Import prettify js  -->

    
        
            <script>lsloader.load("prettify_js","/js/prettify.min.js?WN07fivHQSMKWy7BmHBB6w==", true)</script>
        
    



<!-- Window Load -->
<!-- add class for prettify -->
<script type="text/ls-javascript" id="window-load">
    $(window).on('load', function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });

    
        
            $(function() {
                $('pre').addClass('prettyprint linenums').attr('style', 'overflow:auto;');
                prettyPrint();
                })
        
    
    
</script>

<!-- MathJax Load-->

    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({"HTML-CSS": { preferredFont: "TeX", availableFonts: ["STIX","TeX"], linebreaks: { automatic:true }, EqnChunk: (MathJax.Hub.Browser.isMobile ? 10 : 50) },
        tex2jax: { inlineMath: [ ["$", "$"], ["\\(","\\)"] ], processEscapes: true, ignoreClass: "tex2jax_ignore|dno",skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']},
        TeX: {  noUndefined: { attributes: { mathcolor: "red", mathbackground: "#FFEEEE", mathsize: "90%" } }, Macros: { href: "{}" } },
        messageStyle: "none"
    });
</script>
<script type="text/x-mathjax-config">
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for(i=0; i < all.length; i += 1) {
            all[i].SourceElement().parentNode.className += ' has-jax';
        }
    });
</script>

    <script src="true?config=TeX-AMS-MML_HTMLorMML"></script>




<!-- Bing Background -->


<script type="text/ls-javascript" id="lazy-load">
    // Offer LazyLoad
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    // Start Queue
    $(document).ready(function(){
        setInterval(function(){
            queue.execNext();
        },200);
    });
</script>

<!-- Custom Footer -->



<script>
    (function(){
        var scriptList = document.querySelectorAll('script[type="text/ls-javascript"]')

        for (var i = 0; i < scriptList.length; ++i) {
            var item = scriptList[i];
            lsloader.runInlineScript(item.id,item.id);
        }
    })()
console.log('\n %c © Material Theme | Version: 1.5.2 | https://github.com/viosey/hexo-theme-material %c \n', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-left-radius:5px;border-bottom-left-radius:5px;', 'color:#455a64;background:#e0e0e0;padding:5px 0;border-top-right-radius:5px;border-bottom-right-radius:5px;');
</script>

                </main>
            </div>
        <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<!--<script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
-->
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>

</body>
    
</html>
